<?xml version="1.0" encoding="utf-8"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:ext="http://www.liquibase.org/xml/ns/dbchangelog-ext" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.2.xsd http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd">

    <changeSet author="AndriusKarpavicius" id="rebuild-data-decisionRule">
        <insert tableName="wf_decision_rule">
            <column name="id" valueNumeric="1" />
            <column name="version" valueNumeric="0" />
            <column name="condition_el" value="#{mv:getCFValue(entity,'Territory')==_VALUE_}" />
            <column name="name" value="Territory" />
            <column name="type" value="STRING" />
            <column name="value" value="Other" />
            <column name="model" valueNumeric="1" />
        </insert>
        <insert tableName="wf_decision_rule">
            <column name="id" valueNumeric="2" />
            <column name="version" valueNumeric="0" />
            <column name="condition_el" value="#{mv:getCFValue(entity,'Territory')==_VALUE_}" />
            <column name="name" value="Territory" />
            <column name="type" value="STRING" />
            <column name="value" value="south" />
            <column name="model" valueNumeric="0" />
        </insert>
        <insert tableName="wf_decision_rule">
            <column name="id" valueNumeric="3" />
            <column name="version" valueNumeric="0" />
            <column name="condition_el" value="#{mv:getCFValue(entity,'Territory')==_VALUE_}" />
            <column name="name" value="Territory" />
            <column name="type" value="STRING" />
            <column name="value" value="west" />
            <column name="model" valueNumeric="1" />
        </insert>
        <insert tableName="wf_decision_rule">
            <column name="id" valueNumeric="4" />
            <column name="version" valueNumeric="0" />
            <column name="condition_el" value="#{mv:getCFValue(entity,'Territory')==_VALUE_}" />
            <column name="name" value="Territory" />
            <column name="type" value="STRING" />
            <column name="value" value="north" />
            <column name="model" valueNumeric="0" />
        </insert>
        <insert tableName="wf_decision_rule">
            <column name="id" valueNumeric="5" />
            <column name="version" valueNumeric="0" />
            <column name="condition_el" value="#{mv:getCFValue(entity,'SalesAmount')==_VALUE_}" />
            <column name="name" value="Sales amount" />
            <column name="type" value="STRING" />
            <column name="value" value="Other" />
            <column name="model" valueNumeric="1" />
        </insert>
        <insert tableName="wf_decision_rule">
            <column name="id" valueNumeric="6" />
            <column name="version" valueNumeric="0" />
            <column name="condition_el" value="#{mv:getCFValue(entity,'AccountType')==_VALUE_}" />
            <column name="name" value="Account Type" />
            <column name="type" value="STRING" />
            <column name="value" value="Other" />
            <column name="model" valueNumeric="1" />
        </insert>
    </changeSet>

    <changeSet author="AndriusKarpavicius" id="rebuild-data-paymentGateway">
        <insert tableName="ar_payment_gateway">
            <column name="id" valueNumeric="-1" />
            <column name="version" valueNumeric="0" />
            <column name="disabled" valueNumeric="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="code" value="INGENICO_OGONE_SEPA" />
            <column name="description" value="Ingenico API Connect OGONE for Sepa payments" />
            <column name="type" value="NATIF" />
            <column name="payment_method" value="DIRECTDEBIT" />
            <column name="country_id" valueNumeric="70" />
            <column name="implementation_class_name" value="org.meveo.service.payments.impl.IngenicoGatewayPayment" />
            <column name="uuid" value="gateway_INGENICO_ONGONE" />
        </insert>
        <insert tableName="ar_payment_gateway">
            <column name="id" valueNumeric="-2" />
            <column name="version" valueNumeric="0" />

            <column name="created" valueDate="${db.current.time}" />
            <column name="code" value="SLIMPAY_SEPA" />
            <column name="description" value="Slimpay for Sepa payments" />
            <column name="type" value="NATIF" />
            <column name="payment_method" value="DIRECTDEBIT" />
            <column name="implementation_class_name" value="org.meveo.service.payments.impl.SlimpayGatewayPayment" />
            <column name="country_id" valueNumeric="220" />
            <column name="uuid" value="gateway_SLIMPAY" />
        </insert>
        <insert tableName="ar_payment_gateway">
            <column name="id" valueNumeric="-3" />
            <column name="version" valueNumeric="0" />

            <column name="created" valueDate="${db.current.time}" />
            <column name="code" value="INGENICO_OGONE_CARD" />
            <column name="description" value="Ingenico API Connect OGONE for Card payments" />
            <column name="type" value="NATIF" />
            <column name="payment_method" value="CARD" />
            <column name="implementation_class_name" value="org.meveo.service.payments.impl.SlimpayGatewayPayment" />
            <column name="trading_currency_id" value="-2" /><!-- EUR -->
            <column name="uuid" value="gateway_SLIMPAY" />
        </insert>
        <insert tableName="crm_provider_pay_methods">
            <column name="provider_id" valueNumeric="1" />
            <column name="payment_method" value="CARD" />
        </insert>
        <insert tableName="crm_provider_pay_methods">
            <column name="provider_id" valueNumeric="1" />
            <column name="payment_method" value="DIRECTDEBIT" />
        </insert>
        <insert tableName="crm_provider_pay_methods">
            <column name="provider_id" valueNumeric="1" />
            <column name="payment_method" value="PAYPAL" />
        </insert>
        <insert tableName="crm_provider_pay_methods">
            <column name="provider_id" valueNumeric="1" />
            <column name="payment_method" value="STRIPE" />
        </insert>
        <insert tableName="crm_provider_pay_methods">
            <column name="provider_id" valueNumeric="1" />
            <column name="payment_method" value="CHECK" />
        </insert>
    </changeSet>
    
    <changeSet author="AndriusKarpavicius" id="rebuild-data-payment-gateway">
        <sql><![CDATA[INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script)
        VALUES (-10, 0, 0,  ${db.current.time}, 'org.meveo.service.script.demo.CustomGatewayPaymentScript', 'CustomGatewayPaymentScript', 'JAVA', 'package org.meveo.service.script.demo;

import java.io.StringReader;
import java.util.Map;
import javax.xml.xpath.*;
import org.meveo.admin.exception.BusinessException;
import org.meveo.model.payments.*;
import org.meveo.service.script.payment.PaymentScript;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.InputSource;

/**
 * @author anasseh
 */
public class CustomGatewayPaymentScript extends PaymentScript{
    private static final Logger log = LoggerFactory.getLogger(CustomGatewayPaymentScript.class);

    public void createCardToken(Map<String, Object> methodContext) throws BusinessException {
        methodContext.put(PaymentScript.RESULT_TOKEN, "7ced0000-3ab2-000d-6a50-08d4b8a6"+(int )(Math.random() * 1000 + 1));
    }
    public void doPaymentToken(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "PAL");
    }
      public void doPaymentCard(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "PAL_CARD");
    }

    public void doRefundToken(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "RFD");
    }
   public void doRefundCard(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "RFD_CARD");
    }

    private void doIt(Map<String, Object> methodContext,String operationType) throws BusinessException {
        try{
            log.debug("EXECUTE  methodContext {} ", methodContext);
            Long amountCts = (Long)methodContext.get(PaymentScript.CONTEXT_AMOUNT_CTS);
            if(amountCts == null){
                throw new BusinessException("amountCts is null");
            }
            CardPaymentMethod paymentToken = (CardPaymentMethod)methodContext.get(PaymentScript.CONTEXT_TOKEN);
            if(paymentToken == null && (operationType.equals("PAL") || operationType.equals("RFD"))){
                throw new BusinessException("paymentMethod is null");
            }

            //DEMO : get tokenId or card infos from context
            String body  = "{";
            body  += " \"PSPID\" : \"PSPID\" ,";
            body  += " \"USERID\" : \"USERID\" ,";
            body  += " \"PSWD\" : \"PSWD\" ,";
            body  += " \"REFKIND\" :  \"PSPID\" ,";
            body  += " \"REFID\" : \"PSPID\" ,";
            body  += " \"OPERATION\" : \""+operationType +"\" ,";
            body  += " \"AMOUNT\" : \""+amountCts.longValue()+"\" ,";
            body  += " \"SHASIGN\" : \"SHASIGN\" ,";
            body  += " }";


            String paymentResponse = "<root>";
            paymentResponse += "<STATUS>92</STATUS>";
            paymentResponse += "<PAYID>"+((int )(Math.random() * 100000 + 1))+"</PAYID>";
            paymentResponse += "<TRANSACTIONID>92</TRANSACTIONID>";
            paymentResponse += "<CRMTOKEN>clientSide</CRMTOKEN>";
            paymentResponse += "<BRAND>VISA</BRAND>";
            paymentResponse += "<ACCEPTENCE>bankRef</ACCEPTENCE>";
            paymentResponse += "</root>";
            methodContext.put(PaymentScript.RESULT_PAYMENT_STATUS, PaymentStatusEnum.PENDING);
            methodContext.put(PaymentScript.RESULT_PAYMENT_ID, getValue(paymentResponse,"/root/PAYID"));
            methodContext.put(PaymentScript.RESULT_TRANSACTION_ID, getValue(paymentResponse,"/root/TRANSACTIONID"));
            methodContext.put(PaymentScript.RESULT_CODE_CLIENT_SIDE, getValue(paymentResponse,"/root/CRMTOKEN"));
            methodContext.put(PaymentScript.RESULT_PAYMENT_BRAND, getValue(paymentResponse,"/root/BRAND"));
            methodContext.put(PaymentScript.RESULT_BANK_REFERENCE, getValue(paymentResponse,"/root/ACCEPTENCE"));
        } catch (Exception e) {
            throw new BusinessException(e.getMessage());
        }
    }
    private String getValue(String sourceXML,String expression) throws XPathExpressionException{
        InputSource iSource = new InputSource(new StringReader(sourceXML));
        XPathFactory xpathFactory = XPathFactory.newInstance();
        XPath xpath = xpathFactory.newXPath();
        return xpath.evaluate(expression, iSource);
    }
}');]]></sql>

        <sql dbms="mysql"><![CDATA[INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script) VALUES (-10, 0, 0,  ${db.current.time}, 'org.meveo.service.script.demo.CustomGatewayPaymentScript', 'CustomGatewayPaymentScript', 'JAVA', '
            package org.meveo.service.script.demo;

import java.io.StringReader;
import java.util.Map;

import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.meveo.admin.exception.BusinessException;
import org.meveo.model.payments.CardPaymentMethod;
import org.meveo.model.payments.PaymentStatusEnum;
import org.meveo.service.script.payment.PaymentScript;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.xml.sax.InputSource;

/**
 *
 * @author anasseh
 *
 */
public class CustomGatewayPaymentScript extends PaymentScript{
    private static final Logger log = LoggerFactory.getLogger(CustomGatewayPaymentScript.class);

    public void createCardToken(Map<String, Object> methodContext) throws BusinessException {
        methodContext.put(PaymentScript.RESULT_TOKEN, "7ced0000-3ab2-000d-6a50-08d4b8a6"+(int )(Math.random() * 1000 + 1));
    }
    public void doPaymentToken(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "PAL");
    }
      public void doPaymentCard(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "PAL_CARD");
    }

    public void doRefundToken(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "RFD");
    }
   public void doRefundCard(Map<String, Object> methodContext) throws BusinessException {
        doIt(methodContext, "RFD_CARD");
    }

    private void doIt(Map<String, Object> methodContext,String operationType) throws BusinessException {
        try{
            log.debug("EXECUTE  methodContext {} ", methodContext);
            Long amountCts = (Long)methodContext.get(PaymentScript.CONTEXT_AMOUNT_CTS);
            if(amountCts == null){
                throw new BusinessException("amountCts is null");
            }
            CardPaymentMethod paymentToken = (CardPaymentMethod)methodContext.get(PaymentScript.CONTEXT_TOKEN);
            if(paymentToken == null && (operationType.equals("PAL") || operationType.equals("RFD"))){
                throw new BusinessException("paymentMethod is null");
            }

            //DEMO : get tokenId or card infos from context
            String body  = "{";
            body  += " \"PSPID\" : \"PSPID\" ,";
            body  += " \"USERID\" : \"USERID\" ,";
            body  += " \"PSWD\" : \"PSWD\" ,";
            body  += " \"REFKIND\" :  \"PSPID\" ,";
            body  += " \"REFID\" : \"PSPID\" ,";
            body  += " \"OPERATION\" : \""+operationType +"\" ,";
            body  += " \"AMOUNT\" : \""+amountCts.longValue()+"\" ,";
            body  += " \"SHASIGN\" : \"SHASIGN\" ,";
            body  += " }";


            String paymentResponse = "<root>";
            paymentResponse += "<STATUS>92</STATUS>";
            paymentResponse += "<PAYID>"+((int )(Math.random() * 100000 + 1))+"</PAYID>";
            paymentResponse += "<TRANSACTIONID>92</TRANSACTIONID>";
            paymentResponse += "<CRMTOKEN>clientSide</CRMTOKEN>";
            paymentResponse += "<BRAND>VISA</BRAND>";
            paymentResponse += "<ACCEPTENCE>bankRef</ACCEPTENCE>";
            paymentResponse += "</root>";
            methodContext.put(PaymentScript.RESULT_PAYMENT_STATUS, PaymentStatusEnum.PENDING);
            methodContext.put(PaymentScript.RESULT_PAYMENT_ID, getValue(paymentResponse,"/root/PAYID"));
            methodContext.put(PaymentScript.RESULT_TRANSACTION_ID, getValue(paymentResponse,"/root/TRANSACTIONID"));
            methodContext.put(PaymentScript.RESULT_CODE_CLIENT_SIDE, getValue(paymentResponse,"/root/CRMTOKEN"));
            methodContext.put(PaymentScript.RESULT_PAYMENT_BRAND, getValue(paymentResponse,"/root/BRAND"));
            methodContext.put(PaymentScript.RESULT_BANK_REFERENCE, getValue(paymentResponse,"/root/ACCEPTENCE"));
        } catch (Exception e) {
            throw new BusinessException(e.getMessage());
        }
    }
    private String getValue(String sourceXML,String expression) throws XPathExpressionException{
        InputSource iSource = new InputSource(new StringReader(sourceXML));
        XPathFactory xpathFactory = XPathFactory.newInstance();
        XPath xpath = xpathFactory.newXPath();
        return xpath.evaluate(expression, iSource);
    }
}
        ');]]></sql>

        <sql><![CDATA[INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script) VALUES (-11  , 0, 0,  ${db.current.time}, 'org.meveo.service.script.demo.PaymentCallBackScript', 'PaymentCallBackScript', 'JAVA', '
            package org.meveo.service.script.smoove;

import java.util.Map;

import org.meveo.admin.exception.BusinessException;
import org.meveo.model.payments.PaymentStatusEnum;
import org.meveo.service.payments.impl.PaymentService;
import org.meveo.service.script.Script;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 
 * @author anasseh
 *
 *         Script executed after a payment callBack (inbound request), if the payment is rejected , the invoice matching is removed and a new is created with a the new reject
 *         payment account operation
 *
 */

public class PaymentCallBackScript extends Script {

    private static final Logger log = LoggerFactory.getLogger(PaymentCallBackScript.class);
    private PaymentService paymentService = (PaymentService) getServiceInterface("PaymentService");

    @Override
    public void execute(Map<String, Object> methodContext) throws BusinessException {
        log.debug("EXECUTE  methodContext {} ", methodContext);
        @SuppressWarnings("unchecked")
        Map<String, String> params = (Map<String, String>) methodContext.get("params");
        log.info("params:" + params);
        if (params.get("STATUS") == null) {
            throw new BusinessException("Parameter STATUS is required");
        }
        if (params.get("PAYID") == null) {
            throw new BusinessException("Parameter PAYID is required");
        }
        PaymentStatusEnum paymentStatus = PaymentStatusEnum.ACCEPTED;
        if (!"9".equals(params.get("STATUS"))) {
            paymentStatus = PaymentStatusEnum.REJECTED;
        }
        paymentService.paymentCallback(params.get("PAYID"), paymentStatus, params.get("NCERROR"), params.get("NCERROR"));
    }

}
        ');]]></sql>

        <sql><![CDATA[INSERT INTO ${db.schema.adapted}ar_payment_gateway (id, version, disabled, created, updated, code, description, type, payment_method, card_type,
        implementation_class_name, script_instance_id, trading_currency_id, application_el, uuid, creator) VALUES (-10, 0, 0,  ${db.current.time}, NULL, 'customGatewayDemo', 'A customGateway for Demo', 'CUSTOM', 'CARD', NULL, NULL, -10, NULL, NULL,
          '3bb099a3-e72d-49ea-9d96-908e74569e02', 'opencell.admin');]]></sql>

        <sql><![CDATA[INSERT INTO ${db.schema.adapted}adm_notification (id, version, disabled, created, updated, code, description, class_name_filter, event_expression_filter, event_type_filter, creator, updater, counter_instance_id, counter_template_id, script_instance_id, priority) VALUES (-10, 0, 0,  ${db.current.time}, NULL, 'PaymentCallBack', NULL, 'org.meveo.model.notification.InboundRequest',
          '#{event.pathInfo.startsWith("/DEMO/custom_payment-callback?")}', 'INBOUND_REQ', 'opencell.admin', NULL, NULL, NULL, -11, 0);]]></sql>

        <sql><![CDATA[INSERT INTO ${db.schema.adapted}adm_notification_params VALUES (-10, '#{event.getParameters()}', 'params');]]></sql>
        <sql><![CDATA[ UPDATE ${db.schema.adapted}ar_payment_gateway set application_el ='#{"is already setup" eq "OK"}' where code <> 'customGatewayDemo';]]></sql>

    </changeSet>
    
    
    <changeSet author="ZBARIKI" id="#6048_20210326" dbms="postgresql"/>        
    <changeSet author="MohamedSTITANE" id="#6048_20210326" dbms="oracle"/>    

    <changeSet author="AmineBENAICHA" id="#6048_20210611">
        <insert tableName="meveo_script_instance" dbms="postgresql">
            <column name="id" valueNumeric="-30"/>
            <column name="version" valueNumeric="0" />
            <column name="disabled" valueNumeric="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="code" value="org.meveo.service.script.ServiceTemplateToProductScript" />
            <column name="description" value="Migration ServiceTemplate To Product" />
            <column name="src_type" value="JAVA" />
            <column name="script">
                <![CDATA[package org.meveo.service.script;
    
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.meveo.admin.exception.BusinessException;
import org.meveo.admin.util.pagination.PaginationConfiguration;
import org.meveo.api.dto.response.PagingAndFiltering.SortOrder;
import org.meveo.api.exception.EntityDoesNotExistsException;
import org.meveo.model.article.AccountingArticle;
import org.meveo.model.article.ArticleMapping;
import org.meveo.model.article.ArticleMappingLine;
import org.meveo.model.billing.ServiceInstance;
import org.meveo.model.catalog.OfferTemplate;
import org.meveo.model.catalog.ProductChargeTemplateMapping;
import org.meveo.model.catalog.ServiceChargeTemplate;
import org.meveo.model.catalog.ServiceTemplate;
import org.meveo.model.cpq.Product;
import org.meveo.model.cpq.ProductVersion;
import org.meveo.model.cpq.enums.VersionStatusEnum;
import org.meveo.model.cpq.offer.OfferComponent;
import org.meveo.model.tax.TaxClass;
import org.meveo.service.billing.impl.ServiceInstanceService;
import org.meveo.service.billing.impl.article.AccountingArticleService;
import org.meveo.service.billing.impl.article.ArticleMappingLineService;
import org.meveo.service.billing.impl.article.ArticleMappingService;
import org.meveo.service.catalog.impl.OfferTemplateService;
import org.meveo.service.catalog.impl.ServiceTemplateService;
import org.meveo.service.cpq.ProductService;
import org.meveo.service.cpq.ProductVersionService;
import org.meveo.service.tax.TaxClassService;

public class ServiceTemplateToProductScript extends Script {
    private static final long serialVersionUID = -6513133027379352381L;

    // Script parameters
    public static final String DEFAULT_TAX_CLASS_CODE = "NORMAL";
    public static final long ARTICLE_MAPPING_ID = 1L;
    private static final Integer PAGE_COUNT = 100;

    private ServiceInstanceService serviceInstanceService = (ServiceInstanceService) getServiceInterface(ServiceInstanceService.class.getSimpleName());
    private ProductService productService = (ProductService) getServiceInterface(ProductService.class.getSimpleName());
    private ProductVersionService productVersionService = (ProductVersionService) getServiceInterface(ProductVersionService.class.getSimpleName());
    private OfferTemplateService offerTemplateService= (OfferTemplateService) getServiceInterface(OfferTemplateService.class.getSimpleName());
    private AccountingArticleService accountingArticleService = (AccountingArticleService) getServiceInterface(AccountingArticleService.class.getSimpleName());
    private ArticleMappingService articleMappingService = (ArticleMappingService) getServiceInterface(ArticleMappingService.class.getSimpleName());
    private ArticleMappingLineService articleMappingLineService = (ArticleMappingLineService) getServiceInterface(ArticleMappingLineService.class.getSimpleName());
    private ServiceTemplateService serviceTemplateService = (ServiceTemplateService) getServiceInterface(ServiceTemplateService.class.getSimpleName());
    private TaxClassService taxClassService = (TaxClassService) getServiceInterface(TaxClassService.class.getSimpleName());

    private TaxClass defaultTaxClass;
    private ArticleMapping defaultArticleMapping;

    @Override
    public void init(Map<String, Object> methodContext) throws BusinessException {
        defaultTaxClass = taxClassService.findByCode(DEFAULT_TAX_CLASS_CODE);
        if (defaultTaxClass == null) {
            throw new EntityDoesNotExistsException(TaxClass.class, DEFAULT_TAX_CLASS_CODE);
        }

        defaultArticleMapping = articleMappingService.findById(ARTICLE_MAPPING_ID);
        if (defaultArticleMapping == null) {
            throw new EntityDoesNotExistsException(ArticleMapping.class, ARTICLE_MAPPING_ID);
        }
    }

    @Override
    public void execute(Map<String, Object> methodContext) throws BusinessException {
        log.info("Migration started at {}", new Date());

        long count = 0;
        List<ServiceTemplate> serviceTemplates = (List<ServiceTemplate>) methodContext.get("SERVICE_TEMPLATE");
        
        if(serviceTemplates != null && !serviceTemplates.isEmpty()) {
            count = serviceTemplates.size();
            serviceTemplates.forEach(this::map);
        } else {

            count = serviceTemplateService.count(new PaginationConfiguration("id", SortOrder.ASCENDING));

            if (PAGE_COUNT < count) {
                serviceTemplateService.list(new PaginationConfiguration(null, null))
                        .forEach(this::map);
            } else {
                for (int index = 0; index < count; index = index + PAGE_COUNT) {
                    serviceTemplateService.list(new PaginationConfiguration(index, PAGE_COUNT, null, null, null, "id", SortOrder.ASCENDING))
                            .forEach(this::map);
                }
            }
        }

        log.info("Number of services migrated={}", count);
        log.info("Migration ended at {}", new Date());
    }

    public Product map(ServiceTemplate serviceTemplate) {
        Product product = createProduct(serviceTemplate);
        createArticle(product);

        ProductVersion productVersion = createProductVersion(product);

        List<ServiceInstance> serviceInstances = serviceInstanceService.findByServiceTemplate(serviceTemplate);

        serviceInstances.forEach(serviceInstance -> {

            serviceInstance.setProductVersion(productVersion);
            serviceInstance.setServiceTemplate(null);
            serviceInstanceService.update(serviceInstance);

            OfferTemplate offer = serviceInstance.getSubscription().getOffer();
            OfferComponent offerComponent = new OfferComponent();
            offerComponent.setProduct(product);
            offerComponent.setOfferTemplate(offer);
            offer.getOfferComponents().add(offerComponent);
            offer.getOfferServiceTemplates().removeIf(o -> o.getServiceTemplate().getId().equals(serviceTemplate.getId()));
            offerTemplateService.update(offer);
        });

        return product;
    }

    private void createArticle(Product product) {
        product.getProductCharges().stream()
                .map(pc -> pc.getChargeTemplate())
                .forEach(chargeTemplate -> {
                    AccountingArticle accountingArticle;
                    List<AccountingArticle> accountingArticles = accountingArticleService.findByTaxClassAndSubCategory(chargeTemplate.getTaxClass(), chargeTemplate.getInvoiceSubCategory());
                    if(accountingArticles.isEmpty()) {
                        accountingArticle = new AccountingArticle(UUID.randomUUID().toString(), "Migration Accounting article", defaultTaxClass, chargeTemplate.getInvoiceSubCategory());
                        accountingArticleService.create(accountingArticle);
                    } else {
                        accountingArticle = accountingArticles.get(0);
                    }

                    ArticleMappingLine articleMappingLine = new ArticleMappingLine();
                    articleMappingLine.setChargeTemplate(chargeTemplate);
                    articleMappingLine.setArticleMapping(defaultArticleMapping);
                    articleMappingLine.setProduct(product);
                    articleMappingLine.setAccountingArticle(accountingArticle);
                    articleMappingLineService.create(articleMappingLine);
                });

    }

    private Product createProduct(ServiceTemplate serviceTemplate) {
        Product product = new Product();
        product.setCode(serviceTemplate.getCode());
        product.setDescription(serviceTemplate.getDescription());
        List<ProductChargeTemplateMapping> productCharges = getProductCharges(serviceTemplate);
        product.setProductCharges(productCharges);
        product.setCfValues(serviceTemplate.getCfValues());
        product.setCfAccumulatedValues(serviceTemplate.getCfAccumulatedValues());
        product.setDisabled(serviceTemplate.isDisabled());
        productService.create(product);
        return product;
    }

    private ProductVersion createProductVersion(Product product) {
        ProductVersion productVersion= new ProductVersion();
        productVersion.setProduct(product);
        productVersion.setShortDescription(product.getDescription());
        productVersion.setStatus(VersionStatusEnum.PUBLISHED);
        productVersion.setStatusDate(Calendar.getInstance().getTime());
        productVersionService.create(productVersion);
        return productVersion;
    }

    private ProductChargeTemplateMapping mapToProductChargeTemplate(ServiceChargeTemplate serviceCharge) {
        ProductChargeTemplateMapping productChargeTemplateMapping = new ProductChargeTemplateMapping();
        productChargeTemplateMapping.setChargeTemplate(serviceCharge.getChargeTemplate());
        return productChargeTemplateMapping;
    }

    private List<ProductChargeTemplateMapping> getProductCharges(ServiceTemplate serviceTemplate) {
        List<ProductChargeTemplateMapping> productCharges = serviceTemplate.getServiceSubscriptionCharges()
                .stream()
                .map(this::mapToProductChargeTemplate)
                .collect(Collectors.toList());

        productCharges.addAll(
                serviceTemplate.getServiceRecurringCharges()
                        .stream()
                        .map(this::mapToProductChargeTemplate)
                        .collect(Collectors.toList())
        );

        productCharges.addAll(
                serviceTemplate.getServiceTerminationCharges()
                        .stream()
                        .map(this::mapToProductChargeTemplate)
                        .collect(Collectors.toList())
        );

        productCharges.addAll(
                serviceTemplate.getServiceUsageCharges()
                        .stream()
                        .map(this::mapToProductChargeTemplate)
                        .collect(Collectors.toList())
        );
        return productCharges;
    }
}]]>
            </column>
        </insert>
        <!--  escape insert limit of 4000 char for oracle      -->
        <sql dbms="oracle" endDelimiter="/">
            <![CDATA[
            declare
                scriptData Clob;
            begin
                scriptData := to_clob('package org.meveo.service.script;
    
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.meveo.admin.exception.BusinessException;
import org.meveo.admin.util.pagination.PaginationConfiguration;
import org.meveo.api.dto.response.PagingAndFiltering.SortOrder;
import org.meveo.api.exception.EntityDoesNotExistsException;
import org.meveo.model.article.AccountingArticle;
import org.meveo.model.article.ArticleMapping;
import org.meveo.model.article.ArticleMappingLine;
import org.meveo.model.billing.ServiceInstance;
import org.meveo.model.catalog.OfferTemplate;
import org.meveo.model.catalog.ProductChargeTemplateMapping;
import org.meveo.model.catalog.ServiceChargeTemplate;
import org.meveo.model.catalog.ServiceTemplate;
import org.meveo.model.cpq.Product;
import org.meveo.model.cpq.ProductVersion;
import org.meveo.model.cpq.enums.VersionStatusEnum;
import org.meveo.model.cpq.offer.OfferComponent;
import org.meveo.model.tax.TaxClass;
import org.meveo.service.billing.impl.ServiceInstanceService;
import org.meveo.service.billing.impl.article.AccountingArticleService;
import org.meveo.service.billing.impl.article.ArticleMappingLineService;
import org.meveo.service.billing.impl.article.ArticleMappingService;
import org.meveo.service.catalog.impl.OfferTemplateService;
import org.meveo.service.catalog.impl.ServiceTemplateService;
import org.meveo.service.cpq.ProductService;
import org.meveo.service.cpq.ProductVersionService;
import org.meveo.service.tax.TaxClassService;

public class ServiceTemplateToProductScript extends Script {
    private static final long serialVersionUID = -6513133027379352381L;

    // Script parameters
    public static final String DEFAULT_TAX_CLASS_CODE = "NORMAL";
    public static final long ARTICLE_MAPPING_ID = 1L;
    private static final Integer PAGE_COUNT = 100;

    private ServiceInstanceService serviceInstanceService = (ServiceInstanceService) getServiceInterface(ServiceInstanceService.class.getSimpleName());
    private ProductService productService = (ProductService) getServiceInterface(ProductService.class.getSimpleName());
    private ProductVersionService productVersionService = (ProductVersionService) getServiceInterface(ProductVersionService.class.getSimpleName());
    private OfferTemplateService offerTemplateService= (OfferTemplateService) getServiceInterface(OfferTemplateService.class.getSimpleName());
    private AccountingArticleService accountingArticleService = (AccountingArticleService) getServiceInterface(AccountingArticleService.class.getSimpleName());
    private ArticleMappingService articleMappingService = (ArticleMappingService) getServiceInterface(ArticleMappingService.class.getSimpleName());
    private ArticleMappingLineService articleMappingLineService = (ArticleMappingLineService) getServiceInterface(ArticleMappingLineService.class.getSimpleName());
    private ServiceTemplateService serviceTemplateService = (ServiceTemplateService) getServiceInterface(ServiceTemplateService.class.getSimpleName());
    private TaxClassService taxClassService = (TaxClassService) getServiceInterface(TaxClassService.class.getSimpleName());

    private TaxClass defaultTaxClass;
    private ArticleMapping defaultArticleMapping;

    @Override
    public void init(Map<String, Object> methodContext) throws BusinessException {
        defaultTaxClass = taxClassService.findByCode(DEFAULT_TAX_CLASS_CODE);
        if (defaultTaxClass == null) {
            throw new EntityDoesNotExistsException(TaxClass.class, DEFAULT_TAX_CLASS_CODE);
        }

        defaultArticleMapping = articleMappingService.findById(ARTICLE_MAPPING_ID);
        if (defaultArticleMapping == null) {
            throw new EntityDoesNotExistsException(ArticleMapping.class, ARTICLE_MAPPING_ID);
        }
    }

    @Override
    public void execute(Map<String, Object> methodContext) throws BusinessException {
        log.info("Migration started at {}", new Date());

        long count = 0;
        List<ServiceTemplate> serviceTemplates = (List<ServiceTemplate>) methodContext.get("SERVICE_TEMPLATE");
        
        if(serviceTemplates != null && !serviceTemplates.isEmpty()) {
            count = serviceTemplates.size();
            serviceTemplates.forEach(this::map);
        } else {

            count = serviceTemplateService.count(new PaginationConfiguration("id", SortOrder.ASCENDING));

            if (PAGE_COUNT < count) {
                serviceTemplateService.list(new PaginationConfiguration(null, null))
                        .forEach(this::map);
            } else {
                for (int index = 0; index < count; index = index + PAGE_COUNT) {
                    serviceTemplateService.list(new PaginationConfiguration(index, PAGE_COUNT, null, null, null, "id", SortOrder.ASCENDING))
                            .forEach(this::map);
                }
            }
        }

        log.info("Number of services migrated={}", count);
        log.info("Migration ended at {}", new Date());
    }

    public Product map(ServiceTemplate serviceTemplate) {
        Product product = createProduct(serviceTemplate);
        createArticle(product);

        ProductVersion productVersion = createProductVersion(product);

        List<ServiceInstance> serviceInstances = serviceInstanceService.findByServiceTemplate(serviceTemplate);

        serviceInstances.forEach(serviceInstance -> {

            serviceInstance.setProductVersion(productVersion);
            serviceInstance.setServiceTemplate(null);
            serviceInstanceService.update(serviceInstance);

            OfferTemplate offer = serviceInstance.getSubscription().getOffer();
            OfferComponent offerComponent = new OfferComponent();
            offerComponent.setProduct(product);
            offerComponent.setOfferTemplate(offer);
            offer.getOfferComponents().add(offerComponent);
            offer.getOfferServiceTemplates().removeIf(o -> o.getServiceTemplate().getId().equals(serviceTemplate.getId()));
            offerTemplateService.update(offer);
        });

        return product;
    }

    private void createArticle(Product product) {
        product.getProductCharges().stream()
                .map(pc -> pc.getChargeTemplate())
                .forEach(chargeTemplate -> {
                    AccountingArticle accountingArticle;
                    List<AccountingArticle> accountingArticles = accountingArticleService.findByTaxClassAndSubCategory(chargeTemplate.getTaxClass(), chargeTemplate.getInvoiceSubCategory());
                    if(accountingArticles.isEmpty()) {
                        accountingArticle = new AccountingArticle(UUID.randomUUID().toString(), "Migration Accounting article", defaultTaxClass, chargeTemplate.getInvoiceSubCategory());
                        accountingArticleService.create(accountingArticle);
                    } else {
                        accountingArticle = accountingArticles.get(0);
                    }

                    ArticleMappingLine articleMappingLine = new ArticleMappingLine();
                    articleMappingLine.setChargeTemplate(chargeTemplate);
                    articleMappingLine.setArticleMapping(defaultArticleMapping);
                    articleMappingLine.setProduct(product);
                    articleMappingLine.setAccountingArticle(accountingArticle);
                    articleMappingLineService.create(articleMappingLine);
                });

    }

    private Product createProduct(ServiceTemplate serviceTemplate) {
        Product product = new Product();
        product.setCode(serviceTemplate.getCode());
        product.setDescription(serviceTemplate.getDescription());
        List<ProductChargeTemplateMapping> productCharges = getProductCharges(serviceTemplate);
        product.setProductCharges(productCharges);
        product.setCfValues(serviceTemplate.getCfValues());
        product.setCfAccumulatedValues(serviceTemplate.getCfAccumulatedValues());
        product.setDisabled(serviceTemplate.isDisabled());
        productService.create(product);
        return product;
    }

    private ProductVersion createProductVersion(Product product) {
        ProductVersion productVersion= new ProductVersion();
        productVersion.setProduct(product);
        productVersion.setShortDescription(product.getDescription());
        productVersion.setStatus(VersionStatusEnum.PUBLISHED);
        productVersion.setStatusDate(Calendar.getInstance().getTime());
        productVersionService.create(productVersion);
        return productVersion;
    }

    private ProductChargeTemplateMapping mapToProductChargeTemplate(ServiceChargeTemplate serviceCharge) {
        ProductChargeTemplateMapping productChargeTemplateMapping = new ProductChargeTemplateMapping();
        productChargeTemplateMapping.setChargeTemplate(serviceCharge.getChargeTemplate());
        return productChargeTemplateMapping;
    }

    private List<ProductChargeTemplateMapping> getProductCharges(ServiceTemplate serviceTemplate) {
        List<ProductChargeTemplateMapping> productCharges = serviceTemplate.getServiceSubscriptionCharges()
                .stream()
                .map(this::mapToProductChargeTemplate)
                .collect(Collectors.toList());

        productCharges.addAll(
                serviceTemplate.getServiceRecurringCharges()
                        .stream()
                        .map(this::mapToProductChargeTemplate)
                        .collect(Collectors.toList())
        );

        productCharges.addAll(
                serviceTemplate.getServiceTerminationCharges()
                        .stream()
                        .map(this::mapToProductChargeTemplate)
                        .collect(Collectors.toList())
        );

        productCharges.addAll(
                serviceTemplate.getServiceUsageCharges()
                        .stream()
                        .map(this::mapToProductChargeTemplate)
                        .collect(Collectors.toList())
        );
        return productCharges;
    }
}');
                INSERT INTO meveo_script_instance (ID, VERSION, DISABLED, CREATED, CODE, DESCRIPTION, SRC_TYPE, SCRIPT)
                VALUES (-30, 0, 0, ${db.current.time} , 'org.meveo.service.script.ServiceTemplateToProductScript', 'Migration ServiceTemplate To Product', 'JAVA', scriptData);
            end;
            /
            ]]>
        </sql>
        <insert tableName="meveo_job_instance" dbms="postgresql">
            <column name="id" valueNumeric="-40" />
            <column name="version" valueNumeric="0" />
            <column name="disabled" valueNumeric="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="updated" valueDate="null" />
            <column name="uuid" value="ServiceTemplateToProductJob" />
            <column name="code" value="ServiceTemplateToProductJob" />
            <column name="description" value="ServiceTemplateToProductJob" />
            <column name="job_category" value="MEDIATION" />
            <column name="job_template" value="ScriptingJob" />
            <column name="parametres" valueNumeric="null" />
            <column name="creator" value="opencell.admin" />
            <column name="updater" value="null" />
            <column name="timerentity_id" value="null" />
            <column name="cf_values">
                <![CDATA[
                    {"ScriptingJob_script":[{"entity":{"classname":"org.meveo.model.scripts.ScriptInstance","code":"org.meveo.service.script.ServiceTemplateToProductScript","id":-30}}],"ScriptingJob_TransactionType":[{"string":"REQUIRES_NEW"}]}
                ]]>
            </column>
        </insert>
    </changeSet>
    

    <changeSet id="4316_20190625_job" author="horriKhalid">
        <insert tableName="meveo_job_instance">
            <column name="id" valueNumeric="-22" />
            <column name="version" valueNumeric="0" />
            <column name="created" valueDate="2019-06-25 00:00:00.000" />
            <column name="job_category" value="MEDIATION" />
            <column name="job_template" value="ScriptingJob" />
            <column name="code" value="ValidateBR_Job" />
            <column name="creator" value="opencell.admin" />
            <column name="following_job_id" valueNumeric="-11" />
            <column name="description" value="Validates *all* Billing Runs"></column>
            <column name="uuid" value="ValidateBR_Job" />
            <column name="cf_values" value='{"ScriptingJob_script":[{"entity":{"classname":"org.meveo.model.scripts.ScriptInstance","code":"org.meveo.service.script.ValidateBRScript"}}]}'></column>
        </insert>
    </changeSet>
    <changeSet id="4316_20190625_script" author="horriKhalid">
        <sql><![CDATA[
        INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script) VALUES (-24, 0, 0, ${db.current.time}, 'org.meveo.service.script.ValidateBRScript', 'Validate Billing Runs', 'JAVA', '
            package org.meveo.service.script;

/**
 * @author phung
 *
 */
public class ValidateBRScript extends ValidateBR {

}

        ');
        ]]></sql>
    </changeSet>
    
    
    <changeSet id="#277_20210622" author="TarikFA.">
            <sql><![CDATA[INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script) VALUES (-31, 0, 0, ${db.current.time}, 'org.meveo.service.quote.script.QuoteValidation', 'quote validation', 'JAVA', '
            package org.meveo.service.quote.script;
            public class QuoteValidation extends QuoteValidationScript {}
            ');]]></sql>
            
            <sql><![CDATA[INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script) VALUES (-32, 0, 0, ${db.current.time}, 'org.meveo.service.quote.script.OrderAdvancement', 'order advancemnt script', 'JAVA', '
            package org.meveo.service.quote.script;
            public class OrderAdvancement extends OrderAdvancementScript {}
            ');]]></sql>
            
            <insert tableName="adm_notification">
                <column name="id" value="-11" />
                <column name="version" value="0"/>
                <column name="disabled" value="0"/>
                <column name="created" valueDate="${db.current.time}"/>
                <column name="code" value="NOTIF_QUOTE_VALIDATION"/>
                <column name="class_name_filter" value="org.meveo.model.cpq.CpqQuote"/>
                <column name="event_expression_filter" value="#{event.status == 'ACCEPTED' }"/>
                <column name="event_type_filter" value="STATUS_UPDATED"/>
                <column name="creator" value="opencell.admin"/>
                <column name="script_instance_id" value="-31"/>
                <column name="uuid" value="GENERIC_UUID_CPQUOTE"/>
                <column name="priority" value="0"/>
                <column name="run_async" value="0"/>
                <column name="save_successful_notif" value="1"/>
            </insert>
            
            <insert tableName="adm_notification_params">
                <column name="notification_id" value="-11" />
                <column name="params" value="#{event}" />
                <column name="params_key" value="cpqQuote" />
            </insert>
            
            <insert tableName="adm_script_notification">
                <column name="id" value="-11"/>
            </insert>
            
            
            <insert tableName="adm_notification">
                <column name="id" value="-12" />
                <column name="version" value="0"/>
                <column name="disabled" value="0"/>
                <column name="created" valueDate="${db.current.time}"/>
                <column name="code" value="NOTIF_ORDER_ADVANCEMENT"/>
                <column name="class_name_filter" value="org.meveo.model.cpq.commercial.CommercialOrder"/>
                <column name="event_type_filter" value="ADVT_RATE_INCREASED"/>
                <column name="creator" value="opencell.admin"/>
                <column name="script_instance_id" value="-32"/>
                <column name="uuid" value="GENERIC_UUID_ORDER"/>
                <column name="priority" value="0"/>
                <column name="run_async" value="0"/>
                <column name="save_successful_notif" value="1"/>
            </insert>
            
            <insert tableName="adm_notification_params">
                <column name="notification_id" value="-12" />
                <column name="params" value="#{event}" />
                <column name="params_key" value="commercialOrder" />
            </insert>
            
            <insert tableName="adm_script_notification">
                <column name="id" value="-12"/>
            </insert>
    </changeSet>
    

    <changeSet id="INTRD-263_20210716" author="ZBariki">
        <insert tableName="com_message_template">
            <column name="media" value="EMAIL" />
            <column name="id" valueSequenceNext="com_msg_tmpl_seq" />
            <column name="version" value="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="code" value="REPORT_QUERY_RESULT_SUCCESS" />
            <column name="type" value="OTHER"/>
            <column name="tag_start" value="#{"/>
            <column name="tag_end" value="}" />
            <column name="description" value="Report query result" />
            <column name="subject" value="[opencell] Query result #{reportQueryName} #{startDate}" />
            <column name="htmlcontent">
                <![CDATA[Dear #{userName},<br>
<br>
The result for your query is ready.<br>
Check the result on <a href="#{portalResultLink}">Opencell Portal</a><br>
Query : #{reportQueryName}<br>
Started : #{startDate}<br>
Duration : #{duration}<br>
Line count : #{lineCount}<br>
<br>
Best regards,<br>
Opencell team.
                ]]>
            </column>
        </insert>
        <insert tableName="com_message_template">
            <column name="media" value="EMAIL" />
            <column name="id" valueSequenceNext="com_msg_tmpl_seq"/>
            <column name="version" value="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="code" value="REPORT_QUERY_RESULT_FAILURE" />
            <column name="type" value="OTHER" />
            <column name="tag_start" value="#{" />
            <column name="tag_end" value="}" />
            <column name="description" value="Report query failure notification" />
            <column name="subject" value="[opencell] Query failed #{reportQueryName} #{startDate}" />
            <column name="textcontent">
                <![CDATA[Dear #{userName},

Query execution failed with error :
#{error}

Contact your administrator or support.

Query : #{reportQueryName}
Started : #{startDate}
Duration : #{duration}

Best regards,

Opencell team.
                ]]>
            </column>
        </insert>
    </changeSet>
    
    
   <changeSet id="J215_20210708" author="Mohammed_ELAZZOUZI" dbms="postgresql">
   
        <insert tableName="meveo_script_instance">
            <column name="id" valueNumeric="-43" />
            <column name="version" valueNumeric="0" />
            <column name="code" value="org.meveo.service.script.ServiceImportScript" />
            <column name="src_type" value="JAVA" />
            <column name="description" value="script processor to import service instances]"/>
            <column name="created" valueDate="${db.current.time}" />
            <column name="script"><![CDATA[package org.meveo.service.script;

import java.math.BigDecimal;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.meveo.admin.exception.BusinessException;
import org.meveo.admin.exception.ValidationException;
import org.meveo.model.billing.ServiceInstance;
import org.meveo.model.billing.Subscription;
import org.meveo.model.billing.SubscriptionTerminationReason;
import org.meveo.model.catalog.ServiceTemplate;
import org.meveo.model.crm.CustomFieldTemplate;
import org.meveo.model.crm.custom.CustomFieldMatrixColumn;
import org.meveo.model.crm.custom.CustomFieldStorageTypeEnum;
import org.meveo.model.crm.custom.CustomFieldTypeEnum;
import org.meveo.model.shared.DateUtils;
import org.meveo.service.billing.impl.ServiceInstanceService;
import org.meveo.service.billing.impl.SubscriptionService;
import org.meveo.service.catalog.impl.ServiceTemplateService;
import org.meveo.service.crm.impl.CustomFieldTemplateService;
import org.meveo.service.crm.impl.SubscriptionTerminationReasonService;


public class ServiceImportScript extends Script {

	private static final String DATE_FORMAT_PATTERN = "yyyy-MM-dd";
	private static final String RECORD_VARIABLE_NAME = "record";

	private ServiceInstanceService serviceInstanceService = (ServiceInstanceService) getServiceInterface(
			"ServiceInstanceService");
	CustomFieldTemplateService customFieldTemplateService =(CustomFieldTemplateService) getServiceInterface(
			"CustomFieldTemplateService");
	private ServiceTemplateService serviceTemplateService = (ServiceTemplateService) getServiceInterface(
			"ServiceTemplateService");
	private SubscriptionService subscriptionService = (SubscriptionService) getServiceInterface(
			"SubscriptionService");
	private SubscriptionTerminationReasonService reasonService = (SubscriptionTerminationReasonService) getServiceInterface(
			"SubscriptionTerminationReasonService");
	@Override
	public void execute(Map<String, Object> context) throws BusinessException {
		try {
			Map<String, Object> recordMap = (Map<String, Object>) context.get(RECORD_VARIABLE_NAME);
			if (recordMap != null && !recordMap.isEmpty()) {
				DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
				String OC_ENTITY = (String) recordMap.get("OC_ENTITY");
				if (!"ServiceInstance".equals(OC_ENTITY)) {
					throw new ValidationException("value of OC_ENTITY is not correct: " + OC_ENTITY);
				}
				String OC_ACTION = (String) recordMap.get("OC_ACTION");
				if (!Stream.of(ServiceInstanceActionEnum.values()).anyMatch(e -> e.toString().equals(OC_ACTION))) {
					throw new ValidationException("value of OC_ACTION is not correct: " + OC_ACTION);
				}
				ServiceInstanceActionEnum action = ServiceInstanceActionEnum.valueOf(OC_ACTION);

				String OC_Subscription_code = (String) recordMap.get("OC_Subscription_code");
				String OC_ServiceInstance_code = (String) recordMap.get("OC_ServiceInstance_code");
				List<ServiceInstance> serviceInstances = serviceInstanceService
						.findByCodeAndCodeSubscription(OC_ServiceInstance_code, OC_Subscription_code);
				
				ServiceInstance serviceInstance = null;
				if (action==ServiceInstanceActionEnum.INSTANTIATE ) {
					serviceInstance = new ServiceInstance();
					mapServiceInstanceFields(recordMap, serviceInstance);
					serviceInstance.setCode(OC_ServiceInstance_code);
					Subscription subscription = subscriptionService.findByCode(OC_Subscription_code);
					if(subscription==null) {
						throw new ValidationException("no Subscription found with subscriptionCode: '" + OC_Subscription_code + "'");
					}
					serviceInstance.setSubscription(subscription );
					ServiceTemplate serviceTemplate = serviceTemplateService.findByCode(OC_ServiceInstance_code);
					if(serviceTemplate==null) {
						throw new ValidationException("no serviceTemplate found with code: '" + OC_ServiceInstance_code + "'");
					}
					serviceInstance.setServiceTemplate(serviceTemplate);
					serviceInstanceService.create(serviceInstance);
				} else {
					if (serviceInstances == null || serviceInstances.isEmpty()) {
						throw new ValidationException("no ServiceInstanceFound for subscriptionCode/serviceInstanceCode: '"
										+ OC_Subscription_code + "'/'" + OC_ServiceInstance_code + "'");
					}
					serviceInstance = serviceInstances.get(0);
				}
				

				switch (action) {
				case INSTANTIATE:
					serviceInstanceService.serviceInstanciation(serviceInstance);
					break;
				case ACTIVATE:
					serviceInstanceService.serviceActivation(serviceInstance);
					break;
				case RESUME:
					serviceInstanceService.serviceReactivation(serviceInstance, new Date(), true, false);
					break;
				case SUSPEND:
					serviceInstanceService.serviceSuspension(serviceInstance, new Date());
					break;
				case TERMINATE:
					String terminationDate = (String) recordMap.get("OC_terminationDate");
					Date OC_terminationDate = StringUtils.isEmpty(terminationDate) ? new Date() : dateFormat.parse(terminationDate);
					String OC_terminationReason = (String) recordMap.get("OC_terminationReason");
					SubscriptionTerminationReason reason = reasonService.findByCodeReason(OC_terminationReason);
					if(reason==null) {
						throw new ValidationException("no TerminationReason found with code: '" + OC_terminationReason + "'");
					}
					serviceInstanceService.terminateService(serviceInstance, OC_terminationDate, reason, serviceInstance.getOrderNumber());
					break;
				case UPDATE:
					updateService(recordMap, serviceInstance);
					break;
				default:
					break;
				}
			}
		} catch (Exception exception) {
			throw new BusinessException(exception);
		}
	}

	private void updateService(Map<String, Object> recordMap, ServiceInstance serviceInstance) throws Exception {
		mapServiceInstanceFields(recordMap, serviceInstance);
		serviceInstanceService.update(serviceInstance);
	}

	private void mapServiceInstanceFields(Map<String, Object> recordMap, ServiceInstance serviceInstance)
			throws ParseException {
		DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
		String OC_ServiceInstance_subscriptionDate = (String) recordMap.get("OC_ServiceInstance_subscriptionDate");
		String OC_ServiceInstance_rateUntilDate = (String) recordMap.get("OC_ServiceInstance_rateUntilDate");
		String OC_ServiceInstance_endAgreementDate = (String) recordMap.get("OC_ServiceInstance_endAgreementDate");

		Date subscriptionDate = StringUtils.isEmpty(OC_ServiceInstance_subscriptionDate) ? null : dateFormat.parse(OC_ServiceInstance_subscriptionDate);
		Date rateUntilDate = StringUtils.isEmpty(OC_ServiceInstance_rateUntilDate) ? null : dateFormat.parse(OC_ServiceInstance_rateUntilDate);
		Date endAgreementDate = StringUtils.isEmpty(OC_ServiceInstance_endAgreementDate) ? null : dateFormat.parse(OC_ServiceInstance_endAgreementDate);
		String OC_ServiceInstance_description = (String) recordMap.get("OC_ServiceInstance_description");
		String OC_ServiceInstance_quantity = (String) recordMap.get("OC_ServiceInstance_quantity");

		serviceInstance.setSubscriptionDate(subscriptionDate);
		serviceInstance.setRateUntilDate(rateUntilDate);
		serviceInstance.setEndAgreementDate(endAgreementDate);
		serviceInstance.setQuantity(new BigDecimal(OC_ServiceInstance_quantity));
		serviceInstance.setDescription(OC_ServiceInstance_description);
		recordMap.keySet().stream().filter(key -> key.startsWith("CF_"))
				.forEach(key -> serviceInstance.setCfValue(key.substring(3), parseStringCf(key.substring(3), (String)recordMap.get(key))));
	}
	public enum ServiceInstanceActionEnum {
		INSTANTIATE, ACTIVATE, RESUME, SUSPEND, TERMINATE, UPDATE
	}
	
	public Object parseStringCf(String cftCode, String stringCF) {
		
		if (StringUtils.isEmpty(stringCF)) {
            return stringCF;
        }
		CustomFieldTemplate cft=customFieldTemplateService.findByCodeAndAppliesTo(cftCode, "ServiceInstance");
		if (cft == null) {
            throw new BusinessException("No Custom Field exist on ServiceInstance with code "+cftCode);
        }
		CustomFieldStorageTypeEnum storageType = cft.getStorageType();

		switch (storageType) {
		case SINGLE:
			return parseSingleValue(cft, stringCF);
		case MATRIX:
			Map<String, Object> matrix = new HashMap<>();
			final List<CustomFieldMatrixColumn> matrixKeys = cft.getMatrixKeyColumns();
			final List<CustomFieldMatrixColumn> matrixValues = cft.getMatrixValueColumns();
			if (cft.getFieldType() == CustomFieldTypeEnum.MULTI_VALUE) {
				List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
				for (String stringCFLine : stringCFLines) {
					List<String> list = Arrays.asList(stringCFLine.split("\\|"));
					
					final int keySize = matrixKeys.size();
					if (list == null || list.size() != (keySize + matrixValues.size())) {
						throw new ValidationException("Not valid String representation of MATRIX Custom Field : " + cft.getCode() + "/" + stringCF);
					}
					String key = "";
					String value = "";
					for (String s : list.subList(0, keySize)) {
						key = key != "" ? key + "|" + s : s;
					}
					for (String s : list.subList(keySize, list.size())) {
						value = value != "" ? value + "|" + s : s;
					}
					matrix.put(key, value);
				}
			} else {
				List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
				for (String stringCFLine : stringCFLines) {
					List<String> list = Arrays.asList(stringCFLine.split("\\|"));
					final int keySize = matrixKeys.size();
					if (list == null || list.size() != (keySize + 1)) {
						throw new ValidationException("Not valid String representation of MATRIX Custom Field : " + cft.getCode() + "/" + stringCF);
					}
					String key = "";
					for (String s : list.subList(0, keySize)) {
						key = key != "" ? key + "|" + s : s;
					}
					matrix.put(key, parseSingleValue(cft, list.get(list.size() - 1)));
				}
			}
			return matrix;
		case MAP:
			Map<String, Object> map = new HashMap<>();
			if(stringCF.isEmpty()) {
				return map;
			}
			List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
			
			for (String stringCFLine : stringCFLines) {
				List<String> list = Arrays.asList(stringCFLine.split("\\|"));
				if (list == null || list.size() != 2) {
					throw new ValidationException("Not valid String representation of MAP Custom Field : " + cft.getCode() + "/" + stringCF);
				}
				String key = list.get(0);
				map.put(key, parseSingleValue(cft, list.get(1)));
			}
			return map;
		case LIST:
			// TODO
			return stringCF;
		default:
			return stringCF;
		}
	}

	private static Object parseSingleValue(CustomFieldTemplate cft, String stringCF) {
		if (cft.getFieldType() == CustomFieldTypeEnum.DOUBLE) {
		    return Double.parseDouble(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.BOOLEAN) {
		    return Boolean.parseBoolean(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.LONG) {
		    return Long.parseLong(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.STRING || cft.getFieldType() == CustomFieldTypeEnum.LIST || cft.getFieldType() == CustomFieldTypeEnum.CHECKBOX_LIST
		        || cft.getFieldType() == CustomFieldTypeEnum.TEXT_AREA) {
		    return stringCF;
		} else if (cft.getFieldType() == CustomFieldTypeEnum.DATE) {
		    return DateUtils.parseDate(stringCF);
		} else {
			throw new ValidationException("NOT YET IMPLEMENTED");
		}
	}
}]]></column>
        </insert>
        <insert tableName="meveo_script_instance">
            <column name="id" valueNumeric="-44" />
            <column name="version" valueNumeric="0" />
            <column name="code" value="org.meveo.service.script.AccessImportScript" />
            <column name="src_type" value="JAVA" />
            <column name="description" value="script processor to import access points"/>
            <column name="created" valueDate="${db.current.time}"/>
            <column name="script"><![CDATA[package org.meveo.service.script;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.meveo.admin.exception.BusinessException;
import org.meveo.admin.exception.ValidationException;
import org.meveo.model.billing.Subscription;
import org.meveo.model.crm.CustomFieldTemplate;
import org.meveo.model.crm.custom.CustomFieldMatrixColumn;
import org.meveo.model.crm.custom.CustomFieldStorageTypeEnum;
import org.meveo.model.crm.custom.CustomFieldTypeEnum;
import org.meveo.model.mediation.Access;
import org.meveo.model.shared.DateUtils;
import org.meveo.service.billing.impl.SubscriptionService;
import org.meveo.service.crm.impl.CustomFieldTemplateService;
import org.meveo.service.medina.impl.AccessService;

public class AccessImportScript extends Script {

	private static final String DATE_FORMAT_PATTERN = "yyyy-MM-dd";
	private static final String RECORD_VARIABLE_NAME = "record";

	private AccessService accessService = (AccessService) getServiceInterface("AccessService");
	private SubscriptionService subscriptionService = (SubscriptionService) getServiceInterface("SubscriptionService");
	CustomFieldTemplateService customFieldTemplateService =(CustomFieldTemplateService) getServiceInterface(
			"CustomFieldTemplateService");

	@Override
	public void execute(Map<String, Object> context) throws BusinessException {
		try {
			Map<String, Object> recordMap = (Map<String, Object>) context.get(RECORD_VARIABLE_NAME);
			if (recordMap != null && !recordMap.isEmpty()) {
				String OC_ENTITY = (String) recordMap.get("OC_ENTITY");
				if (!"AccessPoint".equals(OC_ENTITY)) {
					throw new ValidationException("value of OC_ENTITY is not correct: " + OC_ENTITY);
				}
				String OC_ACTION = (String) recordMap.get("OC_ACTION");
				if (!Stream.of(AccessActionEnum.values()).anyMatch(e -> e.toString().equals(OC_ACTION))) {
					throw new ValidationException("value of OC_ACTION is not correct: " + OC_ACTION);
				}
				AccessActionEnum action = AccessActionEnum.valueOf(OC_ACTION);

				Access access = validateAndGetAccess(action, recordMap);

				if (AccessActionEnum.DELETE.equals(action)) {
					accessService.remove(access);
				} else {
					setAccessValues(recordMap, access);
					if (AccessActionEnum.CREATE.equals(action)) {
				        if (accessService.isDuplicateAndOverlaps(access)) {
				            throw new BusinessException( "Duplicate subscription/access point: '"+access.getSubscription().getCode()+"'/'"+access.getAccessUserId()+"'");
				        }
						accessService.create(access);
					} else if (AccessActionEnum.UPDATE.equals(action)) {
						accessService.update(access);
					}

				}
			}
		} catch (Exception exception) {
			throw new BusinessException(exception);
		}
	}

	private Access validateAndGetAccess(AccessActionEnum action, Map<String, Object> recordMap) {
		Access access = null;
		String OC_subscription_code = (String) recordMap.get("OC_Subscription_code");
		String OC_Access_code = (String) recordMap.get("OC_accessPoint_code");
		List<Access> accessList = accessService.getActiveAccessByCodeAndCodeSubscription(OC_Access_code, OC_subscription_code);
		if (!AccessActionEnum.CREATE.equals(action)) {
			if (accessList == null || accessList.isEmpty()) {
				throw new ValidationException("no Access found for subscriptionCode/AccessCode: '"
						+ OC_subscription_code + "'/'" + OC_Access_code + "'");
			}
			access = accessList.get(0);
		} else {
			access = new Access();
			Subscription subscription = subscriptionService.findByCode(OC_subscription_code);
			if (subscription == null) {
				throw new ValidationException("no subscription found for code: '" + OC_subscription_code + "'");
			}
			access.setSubscription(subscription);
			access.setAccessUserId(OC_Access_code);
		}
		return access;
	}

	private void setAccessValues(Map<String, Object> recordMap, Access access) throws ParseException {
		DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
		String OC_accessPoint_startDate = (String) recordMap.get("OC_accessPoint_startDate");
		String OC_accessPoint_endDate = (String) recordMap.get("OC_accessPoint_endDate");
		Date startDate = StringUtils.isEmpty(OC_accessPoint_startDate) ? null : dateFormat.parse(OC_accessPoint_startDate);
		Date endDate = StringUtils.isEmpty(OC_accessPoint_endDate) ? null : dateFormat.parse(OC_accessPoint_endDate);
		access.setEndDate(endDate);
		access.setStartDate(startDate);

		recordMap.keySet().stream().filter(key -> key.startsWith("CF_"))
				.forEach(key -> access.setCfValue(key.substring(3), parseStringCf(key.substring(3), (String)recordMap.get(key))));
	}

	public enum AccessActionEnum {
		CREATE, UPDATE, DELETE
	}
	
	public Object parseStringCf(String cftCode, String stringCF) {
		
		if (StringUtils.isEmpty(stringCF)) {
            return stringCF;
        }
		CustomFieldTemplate cft=customFieldTemplateService.findByCodeAndAppliesTo(cftCode, "Access");
		if (cft == null) {
            throw new BusinessException("No Custom Field exist on Access with code "+cftCode);
        }
		CustomFieldStorageTypeEnum storageType = cft.getStorageType();
		
		switch (storageType) {
		case SINGLE:
			return parseSingleValue(cft, stringCF);
		case MATRIX:
			Map<String, Object> matrix = new HashMap<>();
			final List<CustomFieldMatrixColumn> matrixKeys = cft.getMatrixKeyColumns();
			final List<CustomFieldMatrixColumn> matrixValues = cft.getMatrixValueColumns();
			if (cft.getFieldType() == CustomFieldTypeEnum.MULTI_VALUE) {
				List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
				for (String stringCFLine : stringCFLines) {
					List<String> list = Arrays.asList(stringCFLine.split("\\|"));
					
					final int keySize = matrixKeys.size();
					if (list == null || list.size() != (keySize + matrixValues.size())) {
						throw new ValidationException("Not valid String representation of MATRIX Custom Field : " + cft.getCode() + "/" + stringCF);
					}
					String key = "";
					String value = "";
					for (String s : list.subList(0, keySize)) {
						key = key != "" ? key + "|" + s : s;
					}
					for (String s : list.subList(keySize, list.size())) {
						value = value != "" ? value + "|" + s : s;
					}
					matrix.put(key, value);
				}
			} else {
				List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
				for (String stringCFLine : stringCFLines) {
					List<String> list = Arrays.asList(stringCFLine.split("\\|"));
					final int keySize = matrixKeys.size();
					if (list == null || list.size() != (keySize + 1)) {
						throw new ValidationException("Not valid String representation of MATRIX Custom Field : " + cft.getCode() + "/" + stringCF);
					}
					String key = "";
					for (String s : list.subList(0, keySize)) {
						key = key != "" ? key + "|" + s : s;
					}
					matrix.put(key, parseSingleValue(cft, list.get(list.size() - 1)));
				}
			}
			return matrix;
		case MAP:
			Map<String, Object> map = new HashMap<>();
			if(stringCF.isEmpty()) {
				return map;
			}
			List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
			
			for (String stringCFLine : stringCFLines) {
				List<String> list = Arrays.asList(stringCFLine.split("\\|"));
				if (list == null || list.size() != 2) {
					throw new ValidationException("Not valid String representation of MAP Custom Field : " + cft.getCode() + "/" + stringCF);
				}
				String key = list.get(0);
				map.put(key, parseSingleValue(cft, list.get(1)));
			}
			return map;
		case LIST:
			// TODO
			return stringCF;
		default:
			return stringCF;
		}
	}

	private static Object parseSingleValue(CustomFieldTemplate cft, String stringCF) {
		if (cft.getFieldType() == CustomFieldTypeEnum.DOUBLE) {
		    return Double.parseDouble(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.BOOLEAN) {
		    return Boolean.parseBoolean(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.LONG) {
		    return Long.parseLong(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.STRING || cft.getFieldType() == CustomFieldTypeEnum.LIST || cft.getFieldType() == CustomFieldTypeEnum.CHECKBOX_LIST
		        || cft.getFieldType() == CustomFieldTypeEnum.TEXT_AREA) {
		    return stringCF;
		} else if (cft.getFieldType() == CustomFieldTypeEnum.DATE) {
		    return DateUtils.parseDate(stringCF);
		} else {
			throw new ValidationException("NOT YET IMPLEMENTED");
		}
	}
}]]></column>
        </insert>
        <insert tableName="meveo_script_instance">
            <column name="id" valueNumeric="-45" />
            <column name="version" valueNumeric="0" />
            <column name="code" value="org.meveo.service.script.SubscriptionImportScript" />
            <column name="src_type" value="JAVA" />
            <column name="description" value="script processor to import subscriptions"/>
            <column name="created" valueDate="${db.current.time}" />
            <column name="script"><![CDATA[package org.meveo.service.script;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;
import org.meveo.admin.exception.BusinessException;
import org.meveo.admin.exception.ValidationException;
import org.meveo.api.exception.EntityDoesNotExistsException;
import org.meveo.model.admin.Seller;
import org.meveo.model.billing.Subscription;
import org.meveo.model.billing.SubscriptionTerminationReason;
import org.meveo.model.billing.UserAccount;
import org.meveo.model.catalog.OfferTemplate;
import org.meveo.model.crm.CustomFieldTemplate;
import org.meveo.model.crm.custom.CustomFieldMatrixColumn;
import org.meveo.model.crm.custom.CustomFieldStorageTypeEnum;
import org.meveo.model.crm.custom.CustomFieldTypeEnum;
import org.meveo.model.shared.DateUtils;
import org.meveo.service.admin.impl.SellerService;
import org.meveo.service.billing.impl.SubscriptionService;
import org.meveo.service.billing.impl.UserAccountService;
import org.meveo.service.catalog.impl.OfferTemplateService;
import org.meveo.service.crm.impl.CustomFieldTemplateService;
import org.meveo.service.crm.impl.SubscriptionTerminationReasonService;

public class SubscriptionImportScript extends Script {

	private static final String DATE_FORMAT_PATTERN = "yyyy-MM-dd";
	private static final String RECORD_VARIABLE_NAME = "record";
	private SubscriptionTerminationReasonService reasonService= (SubscriptionTerminationReasonService) getServiceInterface("SubscriptionTerminationReasonService");
	private SubscriptionService subscriptionService = (SubscriptionService) getServiceInterface("SubscriptionService");
	private UserAccountService userAccountService = (UserAccountService) getServiceInterface("UserAccountService");
	private SellerService sellerService = (SellerService) getServiceInterface("SellerService");
	private OfferTemplateService offerService = (OfferTemplateService) getServiceInterface("OfferTemplateService");
	private CustomFieldTemplateService customFieldTemplateService =(CustomFieldTemplateService) getServiceInterface("CustomFieldTemplateService");

	@Override
	public void execute(Map<String, Object> context) throws BusinessException {
		try {
			Map<String, Object> recordMap = (Map<String, Object>) context.get(RECORD_VARIABLE_NAME);
			if (recordMap != null && !recordMap.isEmpty()) {
				String OC_ENTITY = (String) recordMap.get("OC_ENTITY");
				if (!"SUBSCRIPTION".equals(OC_ENTITY)) {
					throw new ValidationException("value of OC_ENTITY is not correct: " + OC_ENTITY);
				}
				String OC_ACTION = (String) recordMap.get("OC_ACTION");
				if (!Stream.of(SubscriptionActionEnum.values()).anyMatch(e -> e.toString().equals(OC_ACTION))) {
					throw new ValidationException("value of OC_ACTION is not correct: " + OC_ACTION);
				}
				SubscriptionActionEnum action = SubscriptionActionEnum.valueOf(OC_ACTION);

				String OC_subscription_code = (String) recordMap.get("OC_subscription_code");
				Subscription subscription = subscriptionService
						.findByCode(OC_subscription_code);
				if (subscription == null && !SubscriptionActionEnum.CREATE.equals(action)) {
					throw new ValidationException("no Subscription Found for subscriptionCode: '"
							+ OC_subscription_code + "'");
				}
				if (subscription != null && SubscriptionActionEnum.CREATE.equals(action)) {
					throw new ValidationException("subscription already exists with code: '"
							+ OC_subscription_code + "'");
				}

				switch (action) {
				case CREATE:
					subscription = new Subscription();
					subscription.setCode(OC_subscription_code);
					mapSubscriptionValues(recordMap, subscription);
					subscriptionService.create(subscription);
					break;
				case ACTIVATE:
					subscriptionService.activateInstantiatedService(subscription);
					break;
				case RESUME:
					subscriptionService.subscriptionReactivation(subscription, new Date());
					break;
				case SUSPEND:
					subscriptionService.subscriptionSuspension(subscription, new Date());
					break;
				case TERMINATE:
					DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
					Date OC_terminationDate = extractDate(recordMap, dateFormat, "OC_terminationDate");
					String terminationCode = (String)recordMap.get("OC_subscriptionTerminationReason_code");
					if(terminationCode==null) {
						throw new ValidationException("OC_subscriptionTerminationReason_code is mandatory to terminate subscription" );
					}
					SubscriptionTerminationReason terminationReason = reasonService.findByCodeReason(terminationCode);
					if(terminationReason==null) {
						throw new EntityDoesNotExistsException(SubscriptionTerminationReason.class, terminationCode);
					}
					subscription.setSubscriptionTerminationReason(terminationReason);
					subscriptionService.terminateSubscription(subscription, OC_terminationDate, terminationReason, null);
					break;
				case UPDATE:
					mapSubscriptionValues(recordMap, subscription);
					subscriptionService.update(subscription);
					break;
				default:
					break;
				}
			}
		} catch (Exception exception) {
			throw new BusinessException(exception);
		}
	}

	private void mapSubscriptionValues(Map<String, Object> recordMap, Subscription subscription) throws ParseException {
		DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT_PATTERN);
		String OC_seller_code = (String) recordMap.get("OC_seller_code");
		String OC_offer_code = (String) recordMap.get("OC_offer_code");
		String OC_userAccount_code = (String) recordMap.get("OC_userAccount_code");
		Date subscriptionDate = extractDate(recordMap, dateFormat, "OC_subscriptionDate");
		Date endAgreementDate = extractDate(recordMap, dateFormat, "OC_endAgreementDate");
		Date OC_terminationDate = extractDate(recordMap, dateFormat, "OC_terminationDate");
		
		String OC_subscription_description = (String) recordMap.get("OC_subscription_description");

		

		UserAccount userAccount = userAccountService.findByCode(OC_userAccount_code);
		if(userAccount==null) {
			throw new EntityDoesNotExistsException(UserAccount.class, OC_userAccount_code);
		}
		Seller seller = sellerService.findByCode(OC_seller_code);
		if(seller==null) {
			throw new EntityDoesNotExistsException(Seller.class, OC_seller_code);
		}
		OfferTemplate offer = offerService.findByCode(OC_offer_code);
		if(offer==null) {
			throw new EntityDoesNotExistsException(OfferTemplate.class, OC_offer_code);
		}
		subscription.setUserAccount(userAccount);
		subscription.setSeller(seller);
		subscription.setOffer(offer);
		subscription.setTerminationDate(OC_terminationDate);
		subscription.setSubscriptionDate(subscriptionDate);
		subscription.setEndAgreementDate(endAgreementDate);
		subscription.setDescription(OC_subscription_description);
		recordMap.keySet().stream().filter(key -> key.startsWith("CF_"))
				.forEach(key -> subscription.setCfValue(key.substring(3), parseStringCf(key.substring(3), (String)recordMap.get(key))));
	}

	public enum SubscriptionActionEnum {
		CREATE, UPDATE, SUSPEND, RESUME, ACTIVATE, TERMINATE
	}
	
	private Date extractDate(Map<String, Object> recordMap, DateFormat dateFormat, final String key)
			throws ParseException {
		final String str = (String) recordMap.get(key);
		return StringUtils.isEmpty(str)?null:dateFormat.parse(str);
	}
	
	public Object parseStringCf(String cftCode, String stringCF) {
		if (StringUtils.isEmpty(stringCF)) {
            return stringCF;
        }
		CustomFieldTemplate cft=customFieldTemplateService.findByCodeAndAppliesTo(cftCode, "Subscription");
		if (cft == null) {
            throw new BusinessException("No Custom Field exist on Subscription with code "+cftCode);
        }
		CustomFieldStorageTypeEnum storageType = cft.getStorageType();
        

		switch (storageType) {
		case SINGLE:
			return parseSingleValue(cft, stringCF);
		case MATRIX:
			Map<String, Object> matrix = new HashMap<>();
			final List<CustomFieldMatrixColumn> matrixKeys = cft.getMatrixKeyColumns();
			final List<CustomFieldMatrixColumn> matrixValues = cft.getMatrixValueColumns();
			if (cft.getFieldType() == CustomFieldTypeEnum.MULTI_VALUE) {
				List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
				for (String stringCFLine : stringCFLines) {
					List<String> list = Arrays.asList(stringCFLine.split("\\|"));
					
					final int keySize = matrixKeys.size();
					if (list == null || list.size() != (keySize + matrixValues.size())) {
						throw new ValidationException("Not valid String representation of MATRIX Custom Field : " + cft.getCode() + "/" + stringCF);
					}
					String key = "";
					String value = "";
					for (String s : list.subList(0, keySize)) {
						key = key != "" ? key + "|" + s : s;
					}
					for (String s : list.subList(keySize, list.size())) {
						value = value != "" ? value + "|" + s : s;
					}
					matrix.put(key, value);
				}
			} else {
				List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
				for (String stringCFLine : stringCFLines) {
					List<String> list = Arrays.asList(stringCFLine.split("\\|"));
					final int keySize = matrixKeys.size();
					if (list == null || list.size() != (keySize + 1)) {
						throw new ValidationException("Not valid String representation of MATRIX Custom Field : " + cft.getCode() + "/" + stringCF);
					}
					String key = "";
					for (String s : list.subList(0, keySize)) {
						key = key != "" ? key + "|" + s : s;
					}
					matrix.put(key, parseSingleValue(cft, list.get(list.size() - 1)));
				}
			}
			return matrix;
		case MAP:
			Map<String, Object> map = new HashMap<>();
			if(stringCF.isEmpty()) {
				return map;
			}
			List<String> stringCFLines = stringCF.contains("\n") ? Arrays.asList(stringCF.split("\n")) : Arrays.asList(stringCF);
			
			for (String stringCFLine : stringCFLines) {
				List<String> list = Arrays.asList(stringCFLine.split("\\|"));
				if (list == null || list.size() != 2) {
					throw new ValidationException("Not valid String representation of MAP Custom Field : " + cft.getCode() + "/" + stringCF);
				}
				String key = list.get(0);
				map.put(key, parseSingleValue(cft, list.get(1)));
			}
			return map;
		case LIST:
			// TODO
			return stringCF;
		default:
			return stringCF;
		}
	}

	private static Object parseSingleValue(CustomFieldTemplate cft, String stringCF) {
		if (cft.getFieldType() == CustomFieldTypeEnum.DOUBLE) {
		    return Double.parseDouble(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.BOOLEAN) {
		    return Boolean.parseBoolean(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.LONG) {
		    return Long.parseLong(stringCF);
		} else if (cft.getFieldType() == CustomFieldTypeEnum.STRING || cft.getFieldType() == CustomFieldTypeEnum.LIST || cft.getFieldType() == CustomFieldTypeEnum.CHECKBOX_LIST
		        || cft.getFieldType() == CustomFieldTypeEnum.TEXT_AREA) {
		    return stringCF;
		} else if (cft.getFieldType() == CustomFieldTypeEnum.DATE) {
		    return DateUtils.parseDate(stringCF);
		} else {
			throw new ValidationException("NOT YET IMPLEMENTED");
		}
	}
}]]></column>
        </insert>
   
        <insert tableName="meveo_job_instance">
            <column name="id" valueNumeric="-46" />
            <column name="version" valueNumeric="0" />
            <column name="disabled" valueNumeric="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="updated" valueDate="${db.current.time}" />
            <column name="code" value="importServicesJob" />
            <column name="description" value="importServicesJob" />
            <column name="job_category" value="MEDIATION" />
            <column name="job_template" value="FlatFileProcessingJob" />
            <column name="parametres" valueNumeric="null" />
            <column name="creator" value="opencell.admin" />
            <column name="updater" value="opencell.admin" />
            <column name="timerentity_id" value="null" />
            <column name="following_job_id" value="null" />
            <column name="uuid" value="importServicesJob" />
            <column name="run_on_nodes" value="null" />
            <column name="cluster_behavior" value="LIMIT_TO_SINGLE_NODE" />
            <column name="cf_values">
	            <![CDATA[{"oneFilePerJob":[{"boolean":false}],
	            "FlatFileProcessingJob_outputDir":[{"string":"/imports/services/outputs"}],
	            "FlatFileProcessingJob_mappingConf":[{"string":"<beanio xmlns=\"http://www.beanio.org/2012/03\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd\">\r\n\t<stream name=\"record\" format=\"csv\">\r\n\t\t<parser>\r\n\t\t\t<property name=\"delimiter\" value=\",\" />\r\n\t\t\t<property name=\"comments\" value=\"END\" />\r\n          \t<property name=\"multilineEnabled\" value=\"true\" />\r\n\t\t</parser>\r\n\t\t<record name=\"header\" minOccurs=\"1\" maxOccurs=\"1\" class=\"map\">\r\n\t\t\t<field name=\"OC_ENTITY\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ACTION\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_Subscription_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_description\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_quantity\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_subscriptionDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_rateUntilDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_endAgreementDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_terminationDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_terminationReason\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_APPEL_SORTANT_PPC_ZONE\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_APPEL_SORTANT_PRIXMINUTE_ZONE\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_NRC\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_CHATS_PALIER\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_SMS_ENTRANT\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_PRIX_NRC_REACH\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_COUTPARUNITE_APPEL_ENTRANT\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_LICENCE\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_PRIX_SMS_SORTANT_ZONE\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_UNITAIRE_OPTION\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_PRIX_REC_REACH\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_REC\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_COUT_APPEL_ENTRANT\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_EMAILS_PALIER\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_HITS_PALIER\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_TRANCHE_STOCKAGE_GO\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_TAILLE_TRANCHE_STOCKAGE_GO\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_STOCKAGE_EMAILS_GO_INCLUS\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_MIN_FACTURATION\" ignore=\"true\"/>\r\n\t\t</record>\r\n\t\t<record name=\"details\" minOccurs=\"1\" maxOccurs=\"unbounded\" class=\"map\">\r\n\t\t\t<field name=\"OC_ENTITY\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_ACTION\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_Subscription_code\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_code\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_description\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_quantity\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_subscriptionDate\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_rateUntilDate\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_terminationDate\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_terminationReason\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_ServiceInstance_endAgreementDate\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_APPEL_SORTANT_PPC_ZONE\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_APPEL_SORTANT_PRIXMINUTE_ZONE\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_NRC\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_CHATS_PALIER\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_SMS_ENTRANT\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_PRIX_NRC_REACH\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_COUTPARUNITE_APPEL_ENTRANT\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_LICENCE\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_PRIX_SMS_SORTANT_ZONE\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_UNITAIRE_OPTION\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_PRIX_REC_REACH\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_REC\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MATRICE_COUT_APPEL_ENTRANT\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_EMAILS_PALIER\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_PRIX_HITS_PALIER\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_PRIX_TRANCHE_STOCKAGE_GO\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_TAILLE_TRANCHE_STOCKAGE_GO\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_STOCKAGE_EMAILS_GO_INCLUS\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_MAP_MIN_FACTURATION\" required=\"false\"/>\r\n\t\t</record>\r\n\t</stream>\r\n</beanio>"}],
	            "FlatFileProcessingJob_recordVariableName":[{"string":"record"}],
	            "FlatFileProcessingJob_errorAction":[{"string":"CONTINUE"}],
	            "FlatFileProcessingJob_originFilename":[{"string":"origin_filename"}],
	            "FlatFileProcessingJob_archiveDir":[{"string":"/imports/services/archives"}],
	            "FlatFileProcessingJob_inputDir":[{"string":"/imports/services/inputs"}],
	            "waitingMillis":[{"long":0}],
	            "FlatFileProcessingJob_nbLinesToProcess":[{"long":1}],
	            "FlatFileProcessingJob_formatTransfo":[{"string":"None"}],
	            "FlatFileProcessingJob_rejectDir":[{"string":"/imports/services/rejects"}],
	            "nbRuns":[{"long":1}],
	            "FlatFileProcessingJob_scriptsFlow":[{"string":"org.meveo.service.script.ServiceImportScript"}]}]]>
            </column>
            <column name="verbose_report" value="1" />
          </insert>
          <insert tableName="meveo_job_instance">
            <column name="id" valueNumeric="-47" />
            <column name="version" valueNumeric="0" />
            <column name="disabled" valueNumeric="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="updated" valueDate="${db.current.time}" />
            <column name="code" value="importSubscriptionsJob" />
            <column name="description" value="importSubscriptionsJob" />
            <column name="job_category" value="MEDIATION" />
            <column name="job_template" value="FlatFileProcessingJob" />
            <column name="parametres" valueNumeric="null" />
            <column name="creator" value="opencell.admin" />
            <column name="updater" value="opencell.admin" />
            <column name="timerentity_id" value="null" />
            <column name="following_job_id" value="null" />
            <column name="uuid" value="importSubscriptionsJob" />
            <column name="run_on_nodes" value="null" />
            <column name="cluster_behavior" value="LIMIT_TO_SINGLE_NODE" />
            <column name="cf_values">
	            <![CDATA[{"oneFilePerJob":[{"boolean":false}],
	            "FlatFileProcessingJob_outputDir":[{"string":"/imports/subscriptions/outputs"}],
	            "FlatFileProcessingJob_mappingConf":[{"string":"<beanio\r\n\txmlns=\"http://www.beanio.org/2012/03\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd\">\r\n\t<stream name=\"record\" format=\"csv\">\r\n\t\t<parser>\r\n\t\t\t<property name=\"delimiter\" value=\",\" />\r\n\t\t\t<property name=\"comments\" value=\"END\" />\r\n\t\t\t<property name=\"multilineEnabled\" value=\"true\" />\r\n\t\t</parser>\r\n\t\t<record name=\"header\" minOccurs=\"1\" maxOccurs=\"1\" class=\"map\">\r\n\t\t\t<field name=\"OC_ENTITY\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ACTION\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_subscription_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_subscription_description\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_userAccount_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_offer_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_seller_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_subscriptionDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_endAgreementDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_terminationDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_subscriptionTerminationReason_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_NUM_REACH\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_PAYS_NUM\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_TYPE_NUM\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_NIVEAU_NUM\" ignore=\"true\"/>\r\n\t\t\t<field name=\"CF_CF_NUM_COMMANDE_SUB\" ignore=\"true\"/>\r\n\t\t</record>\r\n\t\t<record name=\"details\" minOccurs=\"1\" maxOccurs=\"unbounded\" class=\"map\">\r\n\t\t\t<field name=\"OC_ENTITY\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_ACTION\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_subscription_code\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_subscription_description\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_userAccount_code\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_offer_code\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_seller_code\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_subscriptionDate\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_endAgreementDate\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_terminationDate\" required=\"false\"/>\r\n\t\t\t<field name=\"OC_subscriptionTerminationReason_code\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_NUM_REACH\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_PAYS_NUM\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_TYPE_NUM\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_NIVEAU_NUM\" required=\"false\"/>\r\n\t\t\t<field name=\"CF_CF_NUM_COMMANDE_SUB\" required=\"false\"/>\r\n\r\n\t\t</record>\r\n\t</stream>\r\n</beanio>"}],
	            "FlatFileProcessingJob_recordVariableName":[{"string":"record"}],
	            "FlatFileProcessingJob_errorAction":[{"string":"CONTINUE"}],
	            "FlatFileProcessingJob_originFilename":[{"string":"origin_filename"}],
	            "FlatFileProcessingJob_archiveDir":[{"string":"/imports/subscriptions/archives"}],
	            "FlatFileProcessingJob_inputDir":[{"string":"/imports/subscriptions/inputs"}],
	            "waitingMillis":[{"long":0}],"FlatFileProcessingJob_nbLinesToProcess":[{"long":1}],
	            "FlatFileProcessingJob_formatTransfo":[{"string":"None"}],"FlatFileProcessingJob_rejectDir":[{"string":"/imports/subscriptions/rejects"}],
	            "nbRuns":[{"long":1}],"FlatFileProcessingJob_scriptsFlow":[{"string":"org.meveo.service.script.SubscriptionImportScript"}]}]]>
            </column>
            <column name="verbose_report" value="1" />
        </insert>
        <insert tableName="meveo_job_instance">
            <column name="id" valueNumeric="-48" />
            <column name="version" valueNumeric="0" />
            <column name="disabled" valueNumeric="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="updated" valueDate="${db.current.time}" />
            <column name="code" value="importAccesPointsJob" />
            <column name="description" value="importAccesPointsJob" />
            <column name="job_category" value="MEDIATION" />
            <column name="job_template" value="FlatFileProcessingJob" />
            <column name="parametres" valueNumeric="null" />
            <column name="creator" value="opencell.admin" />
            <column name="updater" value="opencell.admin" />
            <column name="timerentity_id" value="null" />
            <column name="following_job_id" value="null" />
            <column name="uuid" value="importAccesPointsJob" />
            <column name="run_on_nodes" value="null" />
            <column name="cluster_behavior" value="LIMIT_TO_SINGLE_NODE" />
            <column name="cf_values">
	            <![CDATA[{"oneFilePerJob":[{"boolean":false}],
	            "FlatFileProcessingJob_outputDir":[{"string":"/imports/accessPoints/outputs"}],
	            "FlatFileProcessingJob_mappingConf":[{"string":"<beanio\r\n\txmlns=\"http://www.beanio.org/2012/03\"\r\n\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n  xsi:schemaLocation=\"http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd\">\r\n\t<stream name=\"record\" format=\"csv\">\r\n\t\t<parser>\r\n\t\t\t<property name=\"delimiter\" value=\",\" />\r\n\t\t\t<property name=\"comments\" value=\"END\" />\r\n\t\t\t<property name=\"multilineEnabled\" value=\"true\" />\r\n\t\t</parser>\r\n\t\t<record name=\"header\" minOccurs=\"1\" maxOccurs=\"1\" class=\"map\">\r\n\t\t\t<field name=\"OC_ENTITY\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_ACTION\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_Subscription_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_accessPoint_code\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_accessPoint_startDate\" ignore=\"true\"/>\r\n\t\t\t<field name=\"OC_accessPoint_endDate\" ignore=\"true\"/>\r\n\t\t</record>\r\n\t\t<record name=\"details\" minOccurs=\"1\" maxOccurs=\"unbounded\" class=\"map\">\r\n\t\t\t<field name=\"OC_ENTITY\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_ACTION\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_Subscription_code\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_accessPoint_code\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_accessPoint_startDate\" required=\"true\"/>\r\n\t\t\t<field name=\"OC_accessPoint_endDate\" required=\"true\"/>\r\n\t\t</record>\r\n\t</stream>\r\n</beanio>"}],
	            "FlatFileProcessingJob_recordVariableName":[{"string":"record"}],
	            "FlatFileProcessingJob_errorAction":[{"string":"CONTINUE"}],
	            "FlatFileProcessingJob_originFilename":[{"string":"origin_filename"}],
	            "FlatFileProcessingJob_archiveDir":[{"string":"/imports/accessPoints/archives"}],
	            "FlatFileProcessingJob_inputDir":[{"string":"/imports/accessPoints/inputs"}],
	            "waitingMillis":[{"long":0}],
	            "FlatFileProcessingJob_nbLinesToProcess":[{"long":1}],
	            "FlatFileProcessingJob_formatTransfo":[{"string":"None"}],
	            "FlatFileProcessingJob_rejectDir":[{"string":"/imports/accessPoints/rejects"}],
	            "nbRuns":[{"long":1}],
	            "FlatFileProcessingJob_scriptsFlow":[{"string":"org.meveo.service.script.AccessImportScript"}]}]]>
            </column>
            <column name="verbose_report" value="1" />
        </insert>
	</changeSet>
    
	<changeSet id="1589_20210930" author="YoussefIZEM" dbms="postgresql">
   
        <insert tableName="meveo_script_instance">
            <column name="id" valueNumeric="-55" />
            <column name="version" valueNumeric="0" />
            <column name="code" value="org.meveo.service.script.ProcessCustomerPaymentsFileScript" />
            <column name="src_type" value="JAVA" />
            <column name="description" value="Process customer payments file script"/>
            <column name="created" valueDate="${db.current.time}" />
            <column name="script"><![CDATA[
package org.meveo.service.script;

import java.math.BigDecimal;
import java.util.Date;
import java.util.Map;

import javax.ejb.Stateless;
import javax.inject.Inject;

import org.meveo.admin.exception.BusinessException;
import org.meveo.api.dto.payment.CustomerPaymentRecordDto;
import org.meveo.commons.utils.StringUtils;
import org.meveo.model.billing.BillingAccount;
import org.meveo.model.payments.MatchingStatusEnum;
import org.meveo.model.payments.OCCTemplate;
import org.meveo.model.payments.OperationCategoryEnum;
import org.meveo.model.payments.Payment;
import org.meveo.model.payments.PaymentMethodEnum;
import org.meveo.service.billing.impl.BillingAccountService;
import org.meveo.service.billing.impl.RatingService;
import org.meveo.service.payments.impl.OCCTemplateService;
import org.meveo.service.payments.impl.PaymentService;
import org.meveo.service.script.Script;

import org.meveo.model.payments.ApplicationPropertiesEnum;
import org.meveo.model.payments.AccountOperationCFsEnum;

/**
 * @author Abdellatif BARI
 */
@Stateless
public class ProcessCustomerPaymentsFileScript extends Script {

	private transient BillingAccountService billingAccountService = (BillingAccountService) getServiceInterface(BillingAccountService.class.getSimpleName());
    
    private transient PaymentService paymentService = (PaymentService) getServiceInterface(PaymentService.class.getSimpleName());

	private transient OCCTemplateService oCCTemplateService = (OCCTemplateService) getServiceInterface(OCCTemplateService.class.getSimpleName());

    @Override
    public void execute(Map<String, Object> parameters) throws BusinessException {
        try {
            CustomerPaymentRecordDto customerPaymentRecordDto = initContext(parameters);
            processItem(customerPaymentRecordDto);
        } catch (Exception e) {
            log.error("error on process customer payments file {} ", e.getMessage(), e);
            if (e instanceof BusinessException) {
                throw e;
            } else {
                // wrap the exception in a business exception and throwing it
                throw new BusinessException(e);
            }
        }
    }

    /**
     * Init context
     *
     * @param parameters parameters
     * @return the customer payment record Dto
     * @throws BusinessException the business exception
     */
    private CustomerPaymentRecordDto initContext(Map<String, Object> parameters) throws BusinessException {
        CustomerPaymentRecordDto customerPaymentRecordDto = (CustomerPaymentRecordDto) parameters.get("record");
        if (customerPaymentRecordDto == null) {
            throw new BusinessException(String.format("Parameter record is missing"));
        }
        customerPaymentRecordDto.setErrorMessage(new StringBuilder());
        String fileName = (String) parameters.get("origin_filename");
        if (StringUtils.isBlank(fileName)) {
            throw new BusinessException(String.format("Parameter origin_filename is missing"));
        }
        customerPaymentRecordDto.setFileName(fileName);
        return customerPaymentRecordDto;
    }

    /**
     * Process item
     *
     * @param customerPaymentRecordDto the customerPayment record Dto
     * @throws BusinessException the business exception
     */
    private void processItem(CustomerPaymentRecordDto customerPaymentRecordDto) throws BusinessException {
        validateItem(customerPaymentRecordDto);
        populateItem(customerPaymentRecordDto);
        if (customerPaymentRecordDto.getErrorMessage().length() > 0) {
            throw new BusinessException(customerPaymentRecordDto.getErrorMessage().toString());
        }
    }

    /**
     * Validate item
     *
     * @param customerPaymentRecordDto the customerPayment record Dto
     * @throws BusinessException the business exception
     */
    private void validateItem(CustomerPaymentRecordDto customerPaymentRecordDto) throws BusinessException {
        if (StringUtils.isBlank(customerPaymentRecordDto.getPaidAmount())) {
            customerPaymentRecordDto.getErrorMessage().append("The payment amount is required.");
        } else {
            customerPaymentRecordDto.setPaidAmount(customerPaymentRecordDto.getPaidAmount().trim());
            if (!isDouble(customerPaymentRecordDto.getPaidAmount())) {
                customerPaymentRecordDto.getErrorMessage().append("The payment amount is invalid");
            }
        }
        if (customerPaymentRecordDto.getDate() == null) {
            customerPaymentRecordDto.getErrorMessage().append("The payment date is required");
        }
        if (StringUtils.isBlank(customerPaymentRecordDto.getEndOfRecord()) || !customerPaymentRecordDto.getEndOfRecord().equalsIgnoreCase("V")) {
            customerPaymentRecordDto.getErrorMessage().append("The end of record must always hard coded as V.");
        }
    }

    /**
     * Check number is double
     *
     * @param strNum the string number
     * @return true is the string is double.
     */
    public static boolean isDouble(String strNum) {
        if (StringUtils.isBlank(strNum)) {
            return false;
        }
        try {
            Double.parseDouble(strNum);
        } catch (NumberFormatException nfe) {
            return false;
        }
        return true;
    }
    
    /**
     * Convert String to integer value (possibility to have null as default value)
     *
     * @param str string to be converted
     * @return the integer value
     */
    public static Integer toInteger(String str) {
        return toInteger(str, null);
    }

    /**
     * Convert String to integer value (possibility to have null as default value)
     *
     * @param str          string to be converted
     * @param defaultValue the default value
     * @return the integer value
     */
    public static Integer toInteger(String str, Integer defaultValue) {
        if (StringUtils.isBlank(str)) {
            return defaultValue;
        } else {
            try {
                return Integer.parseInt(str.trim());
            } catch (NumberFormatException ne) {
                return defaultValue;
            }
        }
    }
    
    /**
     * Populate tariff plan item
     *
     * @param customerPaymentRecordDto the customerPayment record Dto
     * @throws BusinessException the business exception
     */
    private void populateItem(CustomerPaymentRecordDto customerPaymentRecordDto) throws BusinessException {
        // if everything is OK and no errors
        if (customerPaymentRecordDto.getErrorMessage().length() == 0) {
            Integer accountNumber = toInteger(customerPaymentRecordDto.getAccountNumber());
            if (accountNumber != null) {
                customerPaymentRecordDto.setAccountNumber(accountNumber.toString());
            }

            BillingAccount billingAccount = billingAccountService.findByNumber(customerPaymentRecordDto.getAccountNumber());
            if (billingAccount != null) {
                // create payment.
                createPayment(customerPaymentRecordDto, billingAccount);
            } else { // the billing account is not found in Opencell
                log.warn("The billing account " + customerPaymentRecordDto.getAccountNumber() + " is not found ");
                postUnmatchedPayment(customerPaymentRecordDto);
            }
        }
    }

    /**
     * post unmatched payment into the suspense billing account
     *
     * @param customerPaymentRecordDto the customerPayment record Dto
     * @throws BusinessException the business exception
     */
    private void postUnmatchedPayment(CustomerPaymentRecordDto customerPaymentRecordDto) throws BusinessException {
        // get the suspense billing account
        String suspenseBillingAccountCode = ApplicationPropertiesEnum.SUSPENSE_BILLING_ACCOUNT_CODE.getProperty();
        BillingAccount billingAccount = billingAccountService.findByCode(suspenseBillingAccountCode);
        if (billingAccount != null) {
            // Create payment and put it into the suspense billing account
            createPayment(customerPaymentRecordDto, billingAccount);
        } else {
            log.error("The suspense billing account {} is not found", suspenseBillingAccountCode);
            customerPaymentRecordDto.getErrorMessage().append("The suspense billing account " + suspenseBillingAccountCode + " is not found ");
        }
    }

    /**
     * create the customer payment
     *
     * @param billingAccount the billing account
     * @return the payment
     * @throws BusinessException the business exception
     */
    private Payment createNewPayment(CustomerPaymentRecordDto customerPaymentRecordDto, BillingAccount billingAccount) throws BusinessException {

        String occTemplateCode = ApplicationPropertiesEnum.TEMPLATE_BATCH_PAYMENT_CREDIT.getProperty();
        OCCTemplate occTemplate = oCCTemplateService.findByCode(occTemplateCode);
        if (occTemplate == null) {
            throw new BusinessException("Cannot find OCC Template with code=" + occTemplateCode);
        }

        BigDecimal amount = new BigDecimal(customerPaymentRecordDto.getPaidAmount()).divide(BigDecimal.valueOf(100));
        /*
         * if (!StringUtils.isBlank(checkDigit)) { checkDigit = checkDigit.trim(); if (checkDigit.equals("-")) { amount = amount.negate(); } }
         */

        Payment payment = new Payment();
        payment.setCustomerAccount(billingAccount.getCustomerAccount());
        payment.setPaymentMethod(PaymentMethodEnum.CARD);
        // payment.setOrderNumber(?);
        payment.setAmountWithoutTax(amount);
        payment.setAmount(amount);
        payment.setMatchingAmount(BigDecimal.ZERO);
        payment.setUnMatchingAmount(amount);
        payment.setAccountingCode(occTemplate.getAccountingCode());
        payment.setCode(occTemplate.getCode());
        payment.setDescription(occTemplate.getDescription());
        payment.setTransactionCategory(OperationCategoryEnum.CREDIT); // EIR must provide the category of the transaction CREDIT or DEBIT
        payment.setAccountCodeClientSide(occTemplate.getAccountCodeClientSide());
        payment.setReference(customerPaymentRecordDto.getReference());
        payment.setTransactionDate(customerPaymentRecordDto.getDate());
        // using the date the file is processed as the Payment Date (to be displayed on the invoice)
        payment.setDueDate(new Date());
        payment.setMatchingStatus(MatchingStatusEnum.O);
        payment.setCfValue(AccountOperationCFsEnum.BILLING_ACCOUNT_NUMBER.name(), billingAccount.getExternalRef1());
        //payment.setCfValue(FROM_AccountOperationCFsEnum.BILLING_ACCOUNT_NUMBER.name(), billingAccount.getExternalRef1());
        payment.setCfValue(AccountOperationCFsEnum.PAYMENT_FILE_ACCOUNT_CUSTOMER_NUMBER.name(), customerPaymentRecordDto.getAccountNumber());
        payment.setCfValue(AccountOperationCFsEnum.PAYMENT_FILE_NAME.name(), customerPaymentRecordDto.getFileName());
        return payment;
    }

    /**
     * create the customer payment
     *
     * @param billingAccount the billing account
     * @return the customer payment record Dto
     * @throws BusinessException the business exception
     */
    private void createPayment(CustomerPaymentRecordDto customerPaymentRecordDto, BillingAccount billingAccount) throws BusinessException {
        try {
            Payment payment = createNewPayment(customerPaymentRecordDto, billingAccount);
            paymentService.create(payment);
        } catch (BusinessException e) {
            log.error("Couldn't create Payement. error : {}", e);
            customerPaymentRecordDto.getErrorMessage().append("Couldn't create payment. error : " + e.getMessage());
        }
    }
}		]]></column>
        </insert>
	</changeSet>

    <changeSet id="INTRD-3765_07012022" author="hichamElHaloui">
        <sql dbms="postgresql"><![CDATA[INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script) VALUES (-23, 0, 0, ${db.current.time}, 'org.meveo.service.script.DeleteCustomersScript', 'DeleteCustomersScript', 'JAVA', 'package org.meveo.service.script;

import static org.apache.commons.lang3.StringUtils.isNotBlank;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections4.MapUtils;
import org.meveo.admin.exception.BusinessException;
import org.meveo.model.billing.WalletInstance;
import org.meveo.model.crm.Customer;
import org.meveo.service.base.BusinessEntityService;
import org.meveo.service.billing.impl.ChargeInstanceService;
import org.meveo.service.billing.impl.CounterInstanceService;
import org.meveo.service.billing.impl.CounterPeriodService;
import org.meveo.service.billing.impl.EdrService;
import org.meveo.service.billing.impl.InvoiceService;
import org.meveo.service.billing.impl.ProductInstanceService;
import org.meveo.service.billing.impl.RatedTransactionService;
import org.meveo.service.billing.impl.RejectedBillingAccountService;
import org.meveo.service.billing.impl.ServiceInstanceService;
import org.meveo.service.billing.impl.SubscriptionService;
import org.meveo.service.billing.impl.WalletOperationService;
import org.meveo.service.billing.impl.WalletService;
import org.meveo.service.crm.impl.CustomerService;
import org.meveo.service.medina.impl.AccessService;
import org.meveo.service.order.OrderItemService;
import org.meveo.service.payments.impl.AccountOperationService;
import org.meveo.service.payments.impl.MatchingAmountService;

import javax.persistence.Query;

/**
 *
 * @author Said Ramli
 */
@SuppressWarnings({ "unchecked", "unused" })
public class DeleteCustomersScript extends Script {

	private final AccountOperationService accountOperationService = (AccountOperationService) getServiceInterface(
			AccountOperationService.class.getSimpleName());
	private final CustomerService customerService = (CustomerService) getServiceInterface(
			CustomerService.class.getSimpleName());
	private final InvoiceService invoiceService = (InvoiceService) getServiceInterface(
			InvoiceService.class.getSimpleName());
	private final SubscriptionService subscriptionService = (SubscriptionService) getServiceInterface(
			SubscriptionService.class.getSimpleName());
	private final RatedTransactionService ratedTransactionService = (RatedTransactionService) getServiceInterface(
			RatedTransactionService.class.getSimpleName());
	private final WalletService walletService = (WalletService) getServiceInterface(
			WalletService.class.getSimpleName());
	private final RejectedBillingAccountService rejectedBillingAccountService = (RejectedBillingAccountService) getServiceInterface(
			RejectedBillingAccountService.class.getSimpleName());
	private final CounterInstanceService counterInstanceService = (CounterInstanceService) getServiceInterface(
			CounterInstanceService.class.getSimpleName());
	private final CounterPeriodService counterPeriodService = (CounterPeriodService) getServiceInterface(
			CounterPeriodService.class.getSimpleName());
	private final OrderItemService orderItemService = (OrderItemService) getServiceInterface(
			OrderItemService.class.getSimpleName());
	private final ProductInstanceService productInstanceService = (ProductInstanceService) getServiceInterface(
			ProductInstanceService.class.getSimpleName());
	private final BusinessEntityService businessEntityService = (BusinessEntityService) getServiceInterface(
			BusinessEntityService.class.getSimpleName());
	private final WalletOperationService walletOperationService = (WalletOperationService) getServiceInterface(
			WalletOperationService.class.getSimpleName());
	private final ServiceInstanceService serviceInstanceService = (ServiceInstanceService) getServiceInterface(
			ServiceInstanceService.class.getSimpleName());

	private final EdrService edrService = (EdrService) getServiceInterface(EdrService.class.getSimpleName());

	@SuppressWarnings("rawtypes")
	private final ChargeInstanceService chargeInstanceService = (ChargeInstanceService) getServiceInterface(
			ChargeInstanceService.class.getSimpleName());

	private static final List<String> noCheckAllowedValues = Arrays.asList("0", "1");

	@Override
	public void execute(Map<String, Object> methodContext) throws BusinessException {

		log.debug(" >>> execute {} ", methodContext.entrySet());

		try {

			Map<String, String> record = (Map<String, String>) methodContext.get("RECORD");
			if (MapUtils.isEmpty(record)) {
				throw new BusinessException(String.format("Parameter RECORD is missing"));
			}

			final String customerCode = record.get("customerCode");
			Customer customer = customerService.findByCode(customerCode);
			if (customer == null) {
				throw new BusinessException(String.format("No customer found having code = %s ", customerCode));
			}

			String noCheckVal = record.get("noCheck");
			if (isNotBlank(noCheckVal) && !noCheckAllowedValues.contains(noCheckVal)) {
				throw new BusinessException(
						String.format("Invalid ''noCheck'' value = %s , allowed values are [0,1]", noCheckVal));
			}
			boolean noCheck = "1".contentEquals(noCheckVal);

			if (!noCheck) {
				// If noCheck is 0 then the following conditions must be met in order to allow
				// deletion:
				// No unmatched AO
				// No open EDR/WO/RT

				this.checkUnmatchedAOs(customer);
				this.checkOpenEDRs(customer);
				this.checkOpenWOs(customer);
				this.checkOpenRTs(customer);
			}

			this.removeCustomerHirarchy(customer);

		} catch (BusinessException be) {
			throw be;
		} catch (Exception e) {
			log.error(" Error executing DeleteCustomersScript ", e);
			throw new BusinessException(e.getMessage());
		}
	}

	private void checkOpenEDRs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start checkOpenEDRs for customer = {} ", customer);
			String query = "select count(edr.id) from EDR edr where edr.status = ''OPEN'' and edr.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId ";

			Object count = edrService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId())
					.getSingleResult();
			log.debug(" count of open EDRs = {} ", count);
			log.debug(" End checkOpenEDRs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] open EDRs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkOpenEDRs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void checkOpenWOs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start checkOpenWOs for customer = {} ", customer);
			String query = "select count(wo.id) from WalletOperation wo where wo.status = ''OPEN'' and wo.chargeInstance.userAccount.billingAccount.customerAccount.customer.id =:customerId ";
			final WalletOperationService walletOperationService = (WalletOperationService) getServiceInterface(
					WalletOperationService.class.getSimpleName());

			Object count = walletOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).getSingleResult();
			log.debug(" count of open WOs = {} ", count);
			log.debug(" End checkOpenWOs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] open WOs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkOpenWOs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void checkOpenRTs(Customer customer) throws BusinessException {
		try {

			log.debug(" Start checkOpenRTs for customer = {} ", customer);
			String query = "select count(rt.id) from RatedTransaction rt where rt.status = ''OPEN'' and rt.billingAccount.customerAccount.customer.id =:customerId ";
			Object count = this.ratedTransactionService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).getSingleResult();
			log.debug(" count of open RTs = {} ", count);
			log.debug(" End checkOpenRTs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] open RTs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkOpenRTs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void checkUnmatchedAOs(Customer customer) throws BusinessException {
		try {

			log.debug(" Start checkUnmatchedAOs for customer = {} ", customer);
			String query = "select count(ao.id) from AccountOperation ao where ao.matchingStatus = ''O'' and ao.customerAccount.customer.id =:customerId ";
			final AccountOperationService accountOperationService = (AccountOperationService) getServiceInterface(
					AccountOperationService.class.getSimpleName());
			Object count = accountOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).getSingleResult();
			log.debug(" count of unmatched AOs = {} ", count);
			log.debug(" End checkUnmatchedAOs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] unmatched AOs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkUnmatchedAOs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeCustomerHirarchy(Customer customer) throws BusinessException {
		log.debug(" Start removeCustomerHirarchy for customer = {} ", customer);

		//
		// A workaround for #4134 , no need for this method if #4134 is fixed (only
		// 6.1.X is concerned)!
      	this.nullifyDDRequestItem(customer);
		this.nullifyAOsSeller(customer);

      	this.removeWalletOperations(customer);
		this.removeChargeInstances(customer);
		// the relationship [SubCategoryInvoiceAgregate <=> WalletInstance] should be broke fisrt
		this.nullifySubCategoryInvoiceAgregatesWallet(customer);
		this.removeRatedTransactions(customer);
		this.nullifyWalletInstanceInUserAccount(customer);
		this.removeWalletInstances(customer);

		this.removePaymentHistory(customer);
//		this.removeRatedTransactions(customer);

		this.removeMatchingAmounts(customer);
		this.nullifyRecordedInvoice(customer);
		this.removeInvoices(customer);



		this.removeServiceInstances(customer);
		this.removeAccess(customer);
		this.removeEDRs(customer);
		this.removeDiscountPlanInstance(customer);
		this.nullifyAOSubscriptions(customer);
		this.removeSubscriptions(customer);
		this.removeRejectedBAs(customer);

		this.removeCounterPeriods(customer);
		this.removeCounterInstances(customer);
		this.removeOrderItems(customer);
		this.removeProductInstances(customer);


		this.customerService.remove(customer);

		log.debug(" End removeCustomerHirarchy for customer = {} ", customer);
	}

	private void nullifyWalletInstanceInUserAccount(Customer customer) {
		try {
			log.debug(" Start removeEDRs for customer = {} ", customer);
		String query = "Update UserAccount ua set ua.wallet = null where ua.wallet.id in (select wi.id from WalletInstance wi where wi.userAccount.billingAccount.customerAccount.customer.id =:customerId)";
		edrService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeEDRs for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeEDRs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeEDRs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeEDRs for customer = {} ", customer);

			String queryText = "delete from EDR edr1 where edr1.id in (select edr.id from EDR edr where edr.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			edrService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeEDRs for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeEDRs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeMatchingAmounts(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeMatchingAmounts for customer = {} ", customer);

			final MatchingAmountService matchingAmountService = (MatchingAmountService) getServiceInterface(MatchingAmountService.class.getSimpleName());
			final String query = "delete from MatchingAmount ma1 where ma1.id in (select ma.id from MatchingAmount ma where ma.accountOperation.customerAccount.customer.id =:customerId )";
			matchingAmountService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeMatchingAmounts for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeMatchingAmounts : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeAccess(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeAccess for customer = {} ", customer);

			final AccessService accessService = (AccessService) getServiceInterface(
					AccessService.class.getSimpleName());

			final String queryText = "delete from Access a1 where a1.id in (select a.id from Access a where a.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			accessService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeAccess for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeAccess : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeServiceInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeServiceInstances for customer = {} ", customer);

			String queryText = "delete from ServiceInstance si1 where si1.id in (select si.id from ServiceInstance si where si.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";
			this.serviceInstanceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeServiceInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeServiceInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeWalletOperations(Customer customer) throws BusinessException {
		try {
			log.debug(" removeWalletOperations for customer={} ", customer);
			String queryText = "delete from WalletOperation wo where wo.id in ( select wo1.id from WalletOperation wo1  where wo1.chargeInstance.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";

			Query query = this.walletOperationService.getEntityManager().createQuery(queryText);
			query.setParameter("customerId", customer.getId());
			query.executeUpdate();
		} catch (Exception e) {
			log.error(" Error on removeWalletOperations : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	/**
	 * using Sub-queries to Resolve Error: ERROR: syntax error at or near "cross"
	 *
	 * @param customer
	 * @throws BusinessException
	 */
	private void removePaymentHistory(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removePaymentHistory for customer = {} ", customer);

			String query = "delete from PaymentHistory ph1 where ph1.id in (select ph2.id from PaymentHistory ph2 where ph2.customerCode=:customerCode) ";
			int count = this.businessEntityService.getEntityManager().createQuery(query)
					.setParameter("customerCode", customer.getCode()).executeUpdate();

			log.debug(" {} PaymentHistory to delete ", count);
			log.debug(" End removePaymentHistory for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removePaymentHistory : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	/**
	 * using Sub-queries to Resolve Error: ERROR: syntax error at or near "cross"
	 *
	 * @param customer
	 * @throws BusinessException
	 */

 private void nullifyDDRequestItem(Customer customer){

    try {
			log.debug(" Start deleteDDRequestItem for customer = {} ", customer);

			String query = "update DDRequestItem ddri set ddri.automatedPayment= null where ddri.automatedPayment.id in (select ao2.id from AccountOperation ao2 where ao2.customerAccount.customer.id =:customerId) ";
			int count = this.accountOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" seller to nullify for {} AOs ", count);
			log.debug(" End nullifyAOsSeller for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifyAOsSeller : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
  }
	private void nullifyAOsSeller(Customer customer) throws BusinessException {
		try {
			log.debug(" Start nullifyAOsSeller for customer = {} ", customer);

			String query = "UPDATE AccountOperation ao1 SET ao1.seller = null where ao1.id in (select ao2.id from AccountOperation ao2 where ao2.customerAccount.customer.id =:customerId) ";
			int count = this.accountOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" seller to nullify for {} AOs ", count);
			log.debug(" End nullifyAOsSeller for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifyAOsSeller : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void nullifySubCategoryInvoiceAgregatesWallet(Customer customer) throws BusinessException {
		try {
			log.debug(" Start nullifySubCategoryInvoiceAgregatesWallet for customer = {} ", customer);

			StringBuilder query = new StringBuilder( "UPDATE SubCategoryInvoiceAgregate subCat SET subCat.wallet = null ")
					.append(" where subCat.id in (select subCatIn.id from SubCategoryInvoiceAgregate subCatIn where subCatIn.wallet.userAccount.billingAccount.customerAccount.customer.id =:customerId) ");

			int count = this.accountOperationService.getEntityManager().createQuery(query.toString()).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" wallet to nullify for {} SubCategoryInvoiceAgregate ", count);
			log.debug(" End nullifySubCategoryInvoiceAgregatesWallet for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifySubCategoryInvoiceAgregatesWallet : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}

	}


	private void removeProductInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeProductInstances for customer = {} ", customer);
			String query = "delete from ProductInstance pi where pi.id in (select p.id from ProductInstance p where p.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			productInstanceService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();
			log.debug(" End removeProductInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeProductInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	private void removeOrderItems(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeOrderItem for customer = {} ", customer);

			String query = "delete from OrderItem oi where oi.id in (select p.id from OrderItem p where p.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";

			orderItemService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeOrderItem for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeOrderItem : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeCounterPeriods(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeCounterPeriods for customer = {} ", customer);
			String queryText = "delete from CounterPeriod cp1 where cp1.id in ( select c.id from CounterPeriod c where c.counterInstance.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			counterInstanceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();
			log.debug(" End removeCounterPeriods for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeCounterPeriods : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeCounterInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeCounterInstances for customer = {} ", customer);

			String query = "delete from CounterInstance c1 where c1.id in (select c.id from CounterInstance c where c.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			counterInstanceService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeCounterInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeCounterInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	private void removeRejectedBAs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeRejectedBAs for customer = {} ", customer);

			String queryText = "delete from RejectedBillingAccount rba1 where rba1.id in (select rba.id from RejectedBillingAccount rba where rba.billingAccount.customerAccount.customer.id =:customerId )";
			rejectedBillingAccountService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeRejectedBAs for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeRejectedBAs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}




	private void nullifyRecordedInvoice(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeRecordedInvoice for customer = {} ", customer);

			String queryText = "update  RecordedInvoice ri   set ri.invoice = null where ri.invoice.id in ( select inv.id from Invoice inv where inv.billingAccount.customerAccount.customer.id =:customerId )";
			invoiceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeRecordedInvoice for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeRecordedInvoice : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeInvoices(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeInvoices for customer = {} ", customer);

			String queryText = "delete from Invoice inv1 where inv1.id in (select inv.id from Invoice inv where inv.billingAccount.customerAccount.customer.id =:customerId )";
			invoiceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeInvoices for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeInvoices : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeWalletInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeWalletInstances for customer = {} ", customer);

			String queryText = "delete from WalletInstance wi1 where wi1.id in (select wi.id from WalletInstance wi where wi.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";
			this.walletService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeWalletInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeWalletInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeRatedTransactions(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeRatedTransactions for customer = {} ", customer);

						String queryText = "delete from RatedTransaction rt1 where rt1.id in (select rt.id from RatedTransaction rt where rt.billingAccount.customerAccount.customer.id =:customerId )";
			Query query =chargeInstanceService.getEntityManager().createQuery(queryText);
			query.setParameter("customerId", customer.getId());
			query.executeUpdate();

			log.debug(" End removeRatedTransactions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeRatedTransactions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}

	}


	private void removeChargeInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeChargeInstances for customer = {} ", customer);

			String queryText = "delete from ChargeInstance ci1 where ci1.id in (select ci.id from ChargeInstance ci where ci.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			Query query =chargeInstanceService.getEntityManager().createQuery(queryText);
			query.setParameter("customerId", customer.getId());
			query.executeUpdate();

			log.debug(" End removeChargeInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeChargeInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	private void nullifyAOSubscriptions(Customer customer) throws BusinessException {
		try {
			log.debug(" Start nullifyAOSubscriptions for customer = {} ", customer);
						String queryText = "update AccountOperation  ao set ao.subscription= null where ao.subscription.id in (select s.id from Subscription s where s.userAccount.billingAccount.customerAccount.customer =:customer) ";
			subscriptionService.getEntityManager().createQuery(queryText).setParameter("customer", customer).executeUpdate();
			log.debug(" End nullifyAOSubscriptions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifyAOSubscriptions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeSubscriptions(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeSubscriptions for customer = {} ", customer);
						String queryText = "delete from Subscription s1 where s1.id in (select s.id from Subscription s where s.userAccount.billingAccount.customerAccount.customer =:customer) ";
			subscriptionService.getEntityManager().createQuery(queryText).setParameter("customer", customer).executeUpdate();
			log.debug(" End removeSubscriptions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeSubscriptions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeDiscountPlanInstance(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeSubscriptions for customer = {} ", customer);
						String queryText = "delete from DiscountPlanInstance dpi where subscription_id in (select s.id from Subscription s where s.userAccount.billingAccount.customerAccount.customer =:customer) ";
			subscriptionService.getEntityManager().createQuery(queryText).setParameter("customer", customer).executeUpdate();
			log.debug(" End removeSubscriptions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeSubscriptions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private <T> Collection<T> safe(Collection<T> collection) {
		return collection == null ? Collections.EMPTY_LIST : collection;
	}
}');]]>
		</sql>
<!--        escape a limit of insert with text bigger than 4000 chars-->
        <sql dbms="oracle" endDelimiter="/">
            <![CDATA[
             declare
                scriptData Clob;
            begin
                scriptData := to_clob('package org.meveo.service.script;

import static org.apache.commons.lang3.StringUtils.isNotBlank;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.collections4.MapUtils;
import org.meveo.admin.exception.BusinessException;
import org.meveo.model.billing.WalletInstance;
import org.meveo.model.crm.Customer;
import org.meveo.service.base.BusinessEntityService;
import org.meveo.service.billing.impl.ChargeInstanceService;
import org.meveo.service.billing.impl.CounterInstanceService;
import org.meveo.service.billing.impl.CounterPeriodService;
import org.meveo.service.billing.impl.EdrService;
import org.meveo.service.billing.impl.InvoiceService;
import org.meveo.service.billing.impl.ProductInstanceService;
import org.meveo.service.billing.impl.RatedTransactionService;
import org.meveo.service.billing.impl.RejectedBillingAccountService;
import org.meveo.service.billing.impl.ServiceInstanceService;
import org.meveo.service.billing.impl.SubscriptionService;
import org.meveo.service.billing.impl.WalletOperationService;
import org.meveo.service.billing.impl.WalletService;
import org.meveo.service.crm.impl.CustomerService;
import org.meveo.service.medina.impl.AccessService;
import org.meveo.service.order.OrderItemService;
import org.meveo.service.payments.impl.AccountOperationService;
import org.meveo.service.payments.impl.MatchingAmountService;

import javax.persistence.Query;

/**
 *
 * @author Said Ramli
 */
@SuppressWarnings({ "unchecked", "unused" })
public class DeleteCustomersScript extends Script {

	private final AccountOperationService accountOperationService = (AccountOperationService) getServiceInterface(
			AccountOperationService.class.getSimpleName());
	private final CustomerService customerService = (CustomerService) getServiceInterface(
			CustomerService.class.getSimpleName());
	private final InvoiceService invoiceService = (InvoiceService) getServiceInterface(
			InvoiceService.class.getSimpleName());
	private final SubscriptionService subscriptionService = (SubscriptionService) getServiceInterface(
			SubscriptionService.class.getSimpleName());
	private final RatedTransactionService ratedTransactionService = (RatedTransactionService) getServiceInterface(
			RatedTransactionService.class.getSimpleName());
	private final WalletService walletService = (WalletService) getServiceInterface(
			WalletService.class.getSimpleName());
	private final RejectedBillingAccountService rejectedBillingAccountService = (RejectedBillingAccountService) getServiceInterface(
			RejectedBillingAccountService.class.getSimpleName());
	private final CounterInstanceService counterInstanceService = (CounterInstanceService) getServiceInterface(
			CounterInstanceService.class.getSimpleName());
	private final CounterPeriodService counterPeriodService = (CounterPeriodService) getServiceInterface(
			CounterPeriodService.class.getSimpleName());
	private final OrderItemService orderItemService = (OrderItemService) getServiceInterface(
			OrderItemService.class.getSimpleName());
	private final ProductInstanceService productInstanceService = (ProductInstanceService) getServiceInterface(
			ProductInstanceService.class.getSimpleName());
	private final BusinessEntityService businessEntityService = (BusinessEntityService) getServiceInterface(
			BusinessEntityService.class.getSimpleName());
	private final WalletOperationService walletOperationService = (WalletOperationService) getServiceInterface(
			WalletOperationService.class.getSimpleName());
	private final ServiceInstanceService serviceInstanceService = (ServiceInstanceService) getServiceInterface(
			ServiceInstanceService.class.getSimpleName());

	private final EdrService edrService = (EdrService) getServiceInterface(EdrService.class.getSimpleName());

	@SuppressWarnings("rawtypes")
	private final ChargeInstanceService chargeInstanceService = (ChargeInstanceService) getServiceInterface(
			ChargeInstanceService.class.getSimpleName());

	private static final List<String> noCheckAllowedValues = Arrays.asList("0", "1");

	@Override
	public void execute(Map<String, Object> methodContext) throws BusinessException {

		log.debug(" >>> execute {} ", methodContext.entrySet());

		try {

			Map<String, String> record = (Map<String, String>) methodContext.get("RECORD");
			if (MapUtils.isEmpty(record)) {
				throw new BusinessException(String.format("Parameter RECORD is missing"));
			}

			final String customerCode = record.get("customerCode");
			Customer customer = customerService.findByCode(customerCode);
			if (customer == null) {
				throw new BusinessException(String.format("No customer found having code = %s ", customerCode));
			}

			String noCheckVal = record.get("noCheck");
			if (isNotBlank(noCheckVal) && !noCheckAllowedValues.contains(noCheckVal)) {
				throw new BusinessException(
						String.format("Invalid ''noCheck'' value = %s , allowed values are [0,1]", noCheckVal));
			}
			boolean noCheck = "1".contentEquals(noCheckVal);

			if (!noCheck) {
				// If noCheck is 0 then the following conditions must be met in order to allow
				// deletion:
				// No unmatched AO
				// No open EDR/WO/RT

				this.checkUnmatchedAOs(customer);
				this.checkOpenEDRs(customer);
				this.checkOpenWOs(customer);
				this.checkOpenRTs(customer);
			}

			this.removeCustomerHirarchy(customer);

		} catch (BusinessException be) {
			throw be;
		} catch (Exception e) {
			log.error(" Error executing DeleteCustomersScript ", e);
			throw new BusinessException(e.getMessage());
		}
	}

	private void checkOpenEDRs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start checkOpenEDRs for customer = {} ", customer);
			String query = "select count(edr.id) from EDR edr where edr.status = ''OPEN'' and edr.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId ";

			Object count = edrService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId())
					.getSingleResult();
			log.debug(" count of open EDRs = {} ", count);
			log.debug(" End checkOpenEDRs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] open EDRs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkOpenEDRs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void checkOpenWOs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start checkOpenWOs for customer = {} ", customer);
			String query = "select count(wo.id) from WalletOperation wo where wo.status = ''OPEN'' and wo.chargeInstance.userAccount.billingAccount.customerAccount.customer.id =:customerId ";
			final WalletOperationService walletOperationService = (WalletOperationService) getServiceInterface(
					WalletOperationService.class.getSimpleName());

			Object count = walletOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).getSingleResult();
			log.debug(" count of open WOs = {} ", count);
			log.debug(" End checkOpenWOs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] open WOs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkOpenWOs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void checkOpenRTs(Customer customer) throws BusinessException {
		try {

			log.debug(" Start checkOpenRTs for customer = {} ", customer);
			String query = "select count(rt.id) from RatedTransaction rt where rt.status = ''OPEN'' and rt.billingAccount.customerAccount.customer.id =:customerId ";
			Object count = this.ratedTransactionService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).getSingleResult();
			log.debug(" count of open RTs = {} ", count);
			log.debug(" End checkOpenRTs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] open RTs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkOpenRTs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void checkUnmatchedAOs(Customer customer) throws BusinessException {
		try {

			log.debug(" Start checkUnmatchedAOs for customer = {} ", customer);
			String query = "select count(ao.id) from AccountOperation ao where ao.matchingStatus = ''O'' and ao.customerAccount.customer.id =:customerId ";
			final AccountOperationService accountOperationService = (AccountOperationService) getServiceInterface(
					AccountOperationService.class.getSimpleName());
			Object count = accountOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).getSingleResult();
			log.debug(" count of unmatched AOs = {} ", count);
			log.debug(" End checkUnmatchedAOs for customer = {} ", customer);

			if (((Long) count).intValue() > 0) {
				throw new BusinessException(" Customer has [" + count + "] unmatched AOs ");
			}
		} catch (Exception e) {
			log.error(" Error on checkUnmatchedAOs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeCustomerHirarchy(Customer customer) throws BusinessException {
		log.debug(" Start removeCustomerHirarchy for customer = {} ", customer);

		//
		// A workaround for #4134 , no need for this method if #4134 is fixed (only
		// 6.1.X is concerned)!
      	this.nullifyDDRequestItem(customer);
		this.nullifyAOsSeller(customer);

      	this.removeWalletOperations(customer);
		this.removeChargeInstances(customer);
		// the relationship [SubCategoryInvoiceAgregate <=> WalletInstance] should be broke fisrt
		this.nullifySubCategoryInvoiceAgregatesWallet(customer);
		this.removeRatedTransactions(customer);
		this.nullifyWalletInstanceInUserAccount(customer);
		this.removeWalletInstances(customer);

		this.removePaymentHistory(customer);
//		this.removeRatedTransactions(customer);

		this.removeMatchingAmounts(customer);
		this.nullifyRecordedInvoice(customer);
		this.removeInvoices(customer);



		this.removeServiceInstances(customer);
		this.removeAccess(customer);
		this.removeEDRs(customer);
		this.removeDiscountPlanInstance(customer);
		this.nullifyAOSubscriptions(customer);
		this.removeSubscriptions(customer);
		this.removeRejectedBAs(customer);

		this.removeCounterPeriods(customer);
		this.removeCounterInstances(customer);
		this.removeOrderItems(customer);
		this.removeProductInstances(customer);


		this.customerService.remove(customer);

		log.debug(" End removeCustomerHirarchy for customer = {} ", customer);
	}

	private void nullifyWalletInstanceInUserAccount(Customer customer) {
		try {
			log.debug(" Start removeEDRs for customer = {} ", customer);
		String query = "Update UserAccount ua set ua.wallet = null where ua.wallet.id in (select wi.id from WalletInstance wi where wi.userAccount.billingAccount.customerAccount.customer.id =:customerId)";
		edrService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeEDRs for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeEDRs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeEDRs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeEDRs for customer = {} ", customer);

			String queryText = "delete from EDR edr1 where edr1.id in (select edr.id from EDR edr where edr.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			edrService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeEDRs for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeEDRs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeMatchingAmounts(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeMatchingAmounts for customer = {} ", customer);

			final MatchingAmountService matchingAmountService = (MatchingAmountService) getServiceInterface(MatchingAmountService.class.getSimpleName());
			final String query = "delete from MatchingAmount ma1 where ma1.id in (select ma.id from MatchingAmount ma where ma.accountOperation.customerAccount.customer.id =:customerId )";
			matchingAmountService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeMatchingAmounts for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeMatchingAmounts : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeAccess(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeAccess for customer = {} ", customer);

			final AccessService accessService = (AccessService) getServiceInterface(
					AccessService.class.getSimpleName());

			final String queryText = "delete from Access a1 where a1.id in (select a.id from Access a where a.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			accessService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeAccess for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeAccess : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeServiceInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeServiceInstances for customer = {} ", customer);

			String queryText = "delete from ServiceInstance si1 where si1.id in (select si.id from ServiceInstance si where si.subscription.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";
			this.serviceInstanceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeServiceInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeServiceInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeWalletOperations(Customer customer) throws BusinessException {
		try {
			log.debug(" removeWalletOperations for customer={} ", customer);
			String queryText = "delete from WalletOperation wo where wo.id in ( select wo1.id from WalletOperation wo1  where wo1.chargeInstance.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";

			Query query = this.walletOperationService.getEntityManager().createQuery(queryText);
			query.setParameter("customerId", customer.getId());
			query.executeUpdate();
		} catch (Exception e) {
			log.error(" Error on removeWalletOperations : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	/**
	 * using Sub-queries to Resolve Error: ERROR: syntax error at or near "cross"
	 *
	 * @param customer
	 * @throws BusinessException
	 */
	private void removePaymentHistory(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removePaymentHistory for customer = {} ", customer);

			String query = "delete from PaymentHistory ph1 where ph1.id in (select ph2.id from PaymentHistory ph2 where ph2.customerCode=:customerCode) ";
			int count = this.businessEntityService.getEntityManager().createQuery(query)
					.setParameter("customerCode", customer.getCode()).executeUpdate();

			log.debug(" {} PaymentHistory to delete ", count);
			log.debug(" End removePaymentHistory for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removePaymentHistory : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	/**
	 * using Sub-queries to Resolve Error: ERROR: syntax error at or near "cross"
	 *
	 * @param customer
	 * @throws BusinessException
	 */

 private void nullifyDDRequestItem(Customer customer){

    try {
			log.debug(" Start deleteDDRequestItem for customer = {} ", customer);

			String query = "update DDRequestItem ddri set ddri.automatedPayment= null where ddri.automatedPayment.id in (select ao2.id from AccountOperation ao2 where ao2.customerAccount.customer.id =:customerId) ";
			int count = this.accountOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" seller to nullify for {} AOs ", count);
			log.debug(" End nullifyAOsSeller for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifyAOsSeller : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
  }
	private void nullifyAOsSeller(Customer customer) throws BusinessException {
		try {
			log.debug(" Start nullifyAOsSeller for customer = {} ", customer);

			String query = "UPDATE AccountOperation ao1 SET ao1.seller = null where ao1.id in (select ao2.id from AccountOperation ao2 where ao2.customerAccount.customer.id =:customerId) ";
			int count = this.accountOperationService.getEntityManager().createQuery(query)
					.setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" seller to nullify for {} AOs ", count);
			log.debug(" End nullifyAOsSeller for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifyAOsSeller : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void nullifySubCategoryInvoiceAgregatesWallet(Customer customer) throws BusinessException {
		try {
			log.debug(" Start nullifySubCategoryInvoiceAgregatesWallet for customer = {} ", customer);

			StringBuilder query = new StringBuilder( "UPDATE SubCategoryInvoiceAgregate subCat SET subCat.wallet = null ")
					.append(" where subCat.id in (select subCatIn.id from SubCategoryInvoiceAgregate subCatIn where subCatIn.wallet.userAccount.billingAccount.customerAccount.customer.id =:customerId) ");

			int count = this.accountOperationService.getEntityManager().createQuery(query.toString()).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" wallet to nullify for {} SubCategoryInvoiceAgregate ", count);
			log.debug(" End nullifySubCategoryInvoiceAgregatesWallet for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifySubCategoryInvoiceAgregatesWallet : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}

	}


	private void removeProductInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeProductInstances for customer = {} ", customer);
			String query = "delete from ProductInstance pi where pi.id in (select p.id from ProductInstance p where p.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			productInstanceService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();
			log.debug(" End removeProductInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeProductInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	private void removeOrderItems(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeOrderItem for customer = {} ", customer);

			String query = "delete from OrderItem oi where oi.id in (select p.id from OrderItem p where p.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";

			orderItemService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeOrderItem for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeOrderItem : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeCounterPeriods(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeCounterPeriods for customer = {} ", customer);
			String queryText = "delete from CounterPeriod cp1 where cp1.id in ( select c.id from CounterPeriod c where c.counterInstance.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			counterInstanceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();
			log.debug(" End removeCounterPeriods for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeCounterPeriods : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeCounterInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeCounterInstances for customer = {} ", customer);

			String query = "delete from CounterInstance c1 where c1.id in (select c.id from CounterInstance c where c.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			counterInstanceService.getEntityManager().createQuery(query).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeCounterInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeCounterInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	private void removeRejectedBAs(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeRejectedBAs for customer = {} ", customer);

			String queryText = "delete from RejectedBillingAccount rba1 where rba1.id in (select rba.id from RejectedBillingAccount rba where rba.billingAccount.customerAccount.customer.id =:customerId )";
			rejectedBillingAccountService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeRejectedBAs for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeRejectedBAs : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}




	private void nullifyRecordedInvoice(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeRecordedInvoice for customer = {} ", customer);

			String queryText = "update  RecordedInvoice ri   set ri.invoice = null where ri.invoice.id in ( select inv.id from Invoice inv where inv.billingAccount.customerAccount.customer.id =:customerId )";
			invoiceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeRecordedInvoice for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeRecordedInvoice : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeInvoices(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeInvoices for customer = {} ", customer);

			String queryText = "delete from Invoice inv1 where inv1.id in (select inv.id from Invoice inv where inv.billingAccount.customerAccount.customer.id =:customerId )";
			invoiceService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeInvoices for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeInvoices : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeWalletInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeWalletInstances for customer = {} ", customer);

			String queryText = "delete from WalletInstance wi1 where wi1.id in (select wi.id from WalletInstance wi where wi.userAccount.billingAccount.customerAccount.customer.id =:customerId) ";
			this.walletService.getEntityManager().createQuery(queryText).setParameter("customerId", customer.getId()).executeUpdate();

			log.debug(" End removeWalletInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeWalletInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private void removeRatedTransactions(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeRatedTransactions for customer = {} ", customer);

						String queryText = "delete from RatedTransaction rt1 where rt1.id in (select rt.id from RatedTransaction rt where rt.billingAccount.customerAccount.customer.id =:customerId )";
			Query query =chargeInstanceService.getEntityManager().createQuery(queryText);
			query.setParameter("customerId", customer.getId());
			query.executeUpdate();

			log.debug(" End removeRatedTransactions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeRatedTransactions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}

	}


	private void removeChargeInstances(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeChargeInstances for customer = {} ", customer);

			String queryText = "delete from ChargeInstance ci1 where ci1.id in (select ci.id from ChargeInstance ci where ci.userAccount.billingAccount.customerAccount.customer.id =:customerId )";
			Query query =chargeInstanceService.getEntityManager().createQuery(queryText);
			query.setParameter("customerId", customer.getId());
			query.executeUpdate();

			log.debug(" End removeChargeInstances for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeChargeInstances : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}


	private void nullifyAOSubscriptions(Customer customer) throws BusinessException {
		try {
			log.debug(" Start nullifyAOSubscriptions for customer = {} ", customer);
						String queryText = "update AccountOperation  ao set ao.subscription= null where ao.subscription.id in (select s.id from Subscription s where s.userAccount.billingAccount.customerAccount.customer =:customer) ";
			subscriptionService.getEntityManager().createQuery(queryText).setParameter("customer", customer).executeUpdate();
			log.debug(" End nullifyAOSubscriptions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on nullifyAOSubscriptions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeSubscriptions(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeSubscriptions for customer = {} ", customer);
						String queryText = "delete from Subscription s1 where s1.id in (select s.id from Subscription s where s.userAccount.billingAccount.customerAccount.customer =:customer) ";
			subscriptionService.getEntityManager().createQuery(queryText).setParameter("customer", customer).executeUpdate();
			log.debug(" End removeSubscriptions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeSubscriptions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}

	private void removeDiscountPlanInstance(Customer customer) throws BusinessException {
		try {
			log.debug(" Start removeSubscriptions for customer = {} ", customer);
						String queryText = "delete from DiscountPlanInstance dpi where subscription_id in (select s.id from Subscription s where s.userAccount.billingAccount.customerAccount.customer =:customer) ";
			subscriptionService.getEntityManager().createQuery(queryText).setParameter("customer", customer).executeUpdate();
			log.debug(" End removeSubscriptions for customer = {} ", customer);
		} catch (Exception e) {
			log.error(" Error on removeSubscriptions : [{}] ", e.getMessage(), e);
			throw new BusinessException(e);
		}
	}



	private <T> Collection<T> safe(Collection<T> collection) {
		return collection == null ? Collections.EMPTY_LIST : collection;
	}
}');

INSERT INTO ${db.schema.adapted}meveo_script_instance (id, version, disabled, created, code, description, src_type, script)
            VALUES (-23, 0, 0, ${db.current.time}, 'org.meveo.service.script.DeleteCustomersScript', 'DeleteCustomersScript', 'JAVA', scriptData);
]]>
        end;
        /
        </sql>
        <insert tableName="meveo_job_instance">
            <column name="id" valueNumeric="-26" />
            <column name="version" valueNumeric="0" />
            <column name="disabled" valueNumeric="0" />
            <column name="created" valueDate="${db.current.time}" />
            <column name="updated" valueDate="${db.current.time}" />
            <column name="code" value="DeleteCustomersScript_JOB" />
            <column name="description" value="DeleteCustomersScript_JOB" />
            <column name="job_category" value="MEDIATION" />
            <column name="job_template" value="FlatFileProcessingJob" />
            <column name="parametres" valueNumeric="null" />
            <column name="creator" value="opencell.admin" />
            <column name="updater" value="opencell.admin" />
            <column name="timerentity_id" value="null" />
            <column name="following_job_id" value="null" />
            <column name="uuid" value="DeleteCustomersScript_JOB" />
            <column name="run_on_nodes" value="null" />
            <column name="cluster_behavior" value="LIMIT_TO_SINGLE_NODE" />

            <column name="cf_values">
	            <![CDATA[{"FlatFileProcessingJob_mappingConf":[{"string":"<beanio xmlns=\"http://www.beanio.org/2012/03\" \r\n      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n      xsi:schemaLocation=\"http://www.beanio.org/2012/03 http://www.beanio.org/2012/03/mapping.xsd\">\r\n      <stream name=\"RECORD\" format=\"csv\" strict=\"true\">\r\n        <parser>\r\n          <property name=\"delimiter\" value=\";\" />\r\n        </parser>     \r\n        <record name=\"customer\"  minOccurs=\"1\" maxOccurs=\"unbounded\" class=\"map\">  \r\n           <field name=\"customerCode\" minOccurs=\"0\" position=\"0\" />\r\n           <field name=\"noCheck\" minOccurs=\"0\" position=\"1\"/>\r\n        </record> \r\n      </stream>\r\n    </beanio>"}]
						,"FlatFileProcessingJob_recordVariableName":[{"string":"RECORD"}]
						,"FlatFileProcessingJob_errorAction":[{"string":"CONTINUE"}]
						,"FlatFileProcessingJob_fileNameExtension":[{"string":"csv"}]
						,"FlatFileProcessingJob_scriptsFlow":[{"string":"org.meveo.service.script.DeleteCustomersScript"}]
						,"FlatFileProcessingJob_inputDir":[{"string":"/batch/customer/delete"}]}]]>
            </column>
            <column name="verbose_report" value="1" />

          </insert>
	</changeSet>
	
	<changeSet id="#4082_20190404" author="SaidRamli"/>
	<changeSet id="#5308_20200618 - Add script" author="AndriusKarpavicius"/>

       <!-- DONT REMOVE THIS CHANGESET - KEEP AT THE BOTTOM OF THE FILE  -->
    <changeSet id="#liquibase_hack_data-scripts" author="AbdelmounaimAkadid">
        <sql>update databasechangelog set filename='src/main/db_resources/changelog/current/data.xml' where filename='src/main/db_resources/changelog/rebuild/data-scripts.xml'</sql>
    </changeSet>

</databaseChangeLog>
